{"meta":{"title":"Flying McDonald","subtitle":"事情总是太多,时间却又太少","description":"相信奇迹的人,本身就像奇迹<br>————麦当<星游记>","author":"Flying McDonald","url":"http://flyingmcdonald.github.io","root":"/"},"pages":[{"title":"文档","date":"2019-07-21T13:33:50.000Z","updated":"2019-07-21T14:03:01.477Z","comments":true,"path":"PDF/index.html","permalink":"http://flyingmcdonald.github.io/PDF/index.html","excerpt":"","text":"Java开发规范"},{"title":"about","date":"2019-07-05T06:49:08.000Z","updated":"2019-07-05T06:49:08.697Z","comments":true,"path":"about/index.html","permalink":"http://flyingmcdonald.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-07-05T06:51:07.000Z","updated":"2019-07-07T06:03:50.969Z","comments":true,"path":"categories/index.html","permalink":"http://flyingmcdonald.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-05T06:50:17.000Z","updated":"2019-07-07T06:03:14.209Z","comments":true,"path":"tags/index.html","permalink":"http://flyingmcdonald.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"样式命名参考","slug":"样式命名参考","date":"2019-09-12T02:06:38.000Z","updated":"2019-09-12T02:50:21.307Z","comments":true,"path":"样式命名参考/","link":"","permalink":"http://flyingmcdonald.github.io/样式命名参考/","excerpt":"","text":"页面功能 命名参考 页面功能 命名参考 页面功能 命名参考 容器 wrap/container/box 头部 header 加入 joinus 导航 nav 底部 footer 注册 register 滚动 scroll 页面主体 main 新闻 news 主导航 mainnav 内容 content 按钮 button 顶导航 topnav 标签页 tab 服务 service 子导航 subnav 版权 copyright 注释 note 菜单 menu 登录 login 提示信息 msg 子菜单 submenu 列表 list 标题 title 子菜单内容 subMenuContent 侧边栏 sidebar 指南 guide 标志 logo 搜索 search 下载 download 广告 banner 图标 icon 状态 status 页面中部 mainbody 表格 table 投票 vote 小技巧 tips 列定义 column_1of3 友情链接 friendlink","categories":[{"name":"web","slug":"web","permalink":"http://flyingmcdonald.github.io/categories/web/"}],"tags":[{"name":"css","slug":"css","permalink":"http://flyingmcdonald.github.io/tags/css/"}]},{"title":"Java数据结构---广度优先搜索遍历","slug":"Java数据结构-广度优先搜索遍历","date":"2019-08-23T15:36:30.000Z","updated":"2019-08-23T16:29:17.186Z","comments":true,"path":"Java数据结构-广度优先搜索遍历/","link":"","permalink":"http://flyingmcdonald.github.io/Java数据结构-广度优先搜索遍历/","excerpt":"介绍 广度优先搜索是一种广泛运用在树或图这类数据结构中，遍历或搜索的算法。 该算法从一个根节点开始，首先访问节点本身。 然后遍历它的相邻节点，其次遍历它的二级邻节点、三级邻节点，以此类推。 当我们在树中进行广度优先搜索时，我们访问的节点的顺序是按照层序遍历顺序的。","text":"介绍 广度优先搜索是一种广泛运用在树或图这类数据结构中，遍历或搜索的算法。 该算法从一个根节点开始，首先访问节点本身。 然后遍历它的相邻节点，其次遍历它的二级邻节点、三级邻节点，以此类推。 当我们在树中进行广度优先搜索时，我们访问的节点的顺序是按照层序遍历顺序的。 通常，我们使用一个叫做队列的数据结构来帮助我们做广度优先搜索。 这是一个广度优先搜索示例 算法 迭代算法 初始化队列只包含一个节点 root 当队列非空的时候： 在输出结果 datas 中插入一个空列表，开始当前层的算法。 计算当前层有多少个元素：等于队列的长度。 将这些元素从队列中弹出，并加入 datas 当前层的空列表中。 将他们的孩子节点作为下一层压入队列中。 123456789101112131415161718192021222324252627282930313233343536 /**迭代算法**/ /** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */ public class Solution &#123; List&lt;List&lt;Integer&gt;&gt; datas = new ArrayList&lt;List&lt;Integer&gt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; if (root == null) &#123; return datas; &#125; queue.offer(root); while (!queue.isEmpty()) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; TreeNode node = queue.poll(); if(node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; list.add(node.val); &#125; datas.add(list); &#125; return datas; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://flyingmcdonald.github.io/categories/数据结构/"}],"tags":[{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/tags/java/"},{"name":"数据结构","slug":"数据结构","permalink":"http://flyingmcdonald.github.io/tags/数据结构/"}]},{"title":"Java数据结构---二叉树","slug":"Java数据结构-二叉树","date":"2019-08-22T16:21:20.000Z","updated":"2019-08-23T15:33:02.163Z","comments":true,"path":"Java数据结构-二叉树/","link":"","permalink":"http://flyingmcdonald.github.io/Java数据结构-二叉树/","excerpt":"介绍 树 是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。 树里的每一个节点有一个根植和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有N 个节点和N-1 条边的一个有向无环图。 二叉树是一种更为典型的树树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。","text":"介绍 树 是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。 树里的每一个节点有一个根植和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有N 个节点和N-1 条边的一个有向无环图。 二叉树是一种更为典型的树树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。 二叉树的遍历 前序遍历遍历顺序：根节点—&gt;左子树—&gt;右子树 中序遍历遍历顺序：左子树—&gt;根节点—&gt;右子树 后序遍历遍历顺序：左子树—&gt;右子树—&gt;根节点 遍历算法 前序遍历 示例： 12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,2,3] 12345678910111213141516171819202122/** 递归算法 **//** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; List&lt;Integer&gt; datas = new ArrayList&lt;Integer&gt;(); public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; while(root != null)&#123; datas.add(root.val); preorderTraversal(root.left); preorderTraversal(root.right); return datas; &#125; return datas; &#125;&#125; 中序遍历 示例： 1234567输入: [1,null,2,3] 1 \\ 2 / 3输出: [1,3,2] 12345678910111213141516171819202122/** 递归算法 **//** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; List&lt;Integer&gt; datas = new ArrayList&lt;Integer&gt;(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; while(root != null)&#123; inorderTraversal(root.left); datas.add(root.val); inorderTraversal(root.right); return datas; &#125; return datas; &#125;&#125; 后序遍历 示例： 1234567输入: [1,null,2,3] 1 \\ 2 / 3输出: [3,2,1] 12345678910111213141516171819202122/** 递归算法 **//** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; List&lt;Integer&gt; datas = new ArrayList&lt;Integer&gt;(); public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; while(root != null)&#123; postorderTraversal(root.left); postorderTraversal(root.right); datas.add(root.val); return datas; &#125; return datas; &#125;&#125; 如果想深入了解树与二叉树，可以阅读这篇博客——Java数据结构和算法（十）——二叉树","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://flyingmcdonald.github.io/categories/数据结构/"}],"tags":[{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/tags/java/"},{"name":"数据结构","slug":"数据结构","permalink":"http://flyingmcdonald.github.io/tags/数据结构/"}]},{"title":"SSM项目踩坑(二)——异步刷新","slug":"SSM项目踩坑-二-——异步请求","date":"2019-08-03T11:51:34.000Z","updated":"2019-08-03T16:24:11.951Z","comments":true,"path":"SSM项目踩坑-二-——异步请求/","link":"","permalink":"http://flyingmcdonald.github.io/SSM项目踩坑-二-——异步请求/","excerpt":"Ajax(Asynchronous Javascript + XML),异步的JavaScript和XML，能在不重新加载整个web页面的前提下刷新数据更改的部分。","text":"Ajax(Asynchronous Javascript + XML),异步的JavaScript和XML，能在不重新加载整个web页面的前提下刷新数据更改的部分。 优点 无刷新更新数据AJAX最大优点就是能在不刷新整个页面的前提下与服务器通信维护数据。这使得Web应用程序更为迅捷地响应用户交互，并避免了在网络上发送那些没有改变的信息，减少用户等待时间，带来非常好的用户体验。 异步与服务器通信AJAX使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。优化了Browser和Server之间的沟通，减少不必要的数据传输、时间及降低网络上数据流量。 前端和后端负载平衡AJAX可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，AJAX的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担，提升站点性能。 基于标准被广泛支持AJAX基于标准化的并被广泛支持的技术，不需要下载浏览器插件或者小程序，但需要客户允许JavaScript在浏览器上执行。随着Ajax的成熟，一些简化Ajax使用方法的程序库也相继问世。同样，也出现了另一种辅助程序设计的技术，为那些不支持JavaScript的用户提供替代功能。 界面与应用分离Ajax使WEB中的界面与应用分离（也可以说是数据与呈现分离），有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。 缺点 AJAX干掉了Back和History功能，即对浏览器机制的破坏在动态更新页面的情况下，用户无法回到前一个页面状态，因为浏览器仅能记忆历史记录中的静态页面。一个被完整读入的页面与一个已经被动态修改过的页面之间的差别非常微妙；用户通常会希望单击后退按钮能够取消他们的前一次操作，但是在Ajax应用程序中，这将无法实现。后退按钮是一个标准的web站点的重要功能，但是它没法和js进行很好的合作。这是Ajax所带来的一个比较严重的问题，因为用户往往是希望能够通过后退来取消前一次操作的。那么对于这个问题有没有办法？答案是肯定的，用过Gmail的知道，Gmail下面采用的Ajax技术解决了这个问题，在Gmail下面是可以后退的，但是，它也并不能改变Ajax的机制，它只是采用的一个比较笨但是有效的办法，即用户单击后退按钮访问历史记录时，通过创建或使用一个隐藏的IFRAME来重现页面上的变更。（例如，当用户在Google Maps中单击后退时，它在一个隐藏的IFRAME中进行搜索，然后将搜索结果反映到Ajax元素上，以便将应用程序状态恢复到当时的状态。）但是，虽然说这个问题是可以解决的，但是它所带来的开发成本是非常高的，并与Ajax框架所要求的快速开发是相背离的。这是Ajax所带来的一个非常严重的问题。一个相关的观点认为，使用动态页面更新使得用户难于将某个特定的状态保存到收藏夹中。该问题的解决方案也已出现，大部分都使用URL片断标识符（通常被称为锚点，即URL中#后面的部分）来保持跟踪，允许用户回到指定的某个应用程序状态。（许多浏览器允许JavaScript动态更新锚点，这使得Ajax应用程序能够在更新显示内容的同时更新锚点。）这些解决方案也同时解决了许多关于不支持后退按钮的争论。 AJAX的安全问题AJAX技术给用户带来很好的用户体验的同时也对IT企业带来了新的安全威胁，Ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。Ajax的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远端服务器上建立新的攻击。还有Ajax也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、SQL注入攻击和基于Credentials的安全漏洞等等。 对搜索引擎支持较弱对搜索引擎的支持比较弱。如果使用不当，AJAX会增大网络数据的流量，从而降低整个系统的性能。 破坏程序的异常处理机制至少从目前看来，像Ajax.dll，Ajaxpro.dll这些Ajax框架是会破坏程序的异常机制的。关于这个问题，曾在开发过程中遇到过，但是查了一下网上几乎没有相关的介绍。后来做了一次试验，分别采用Ajax和传统的form提交的模式来删除一条数据……给我们的调试带来了很大的困难。 违背URL和资源定位的初衷。例如，我给你一个URL地址，如果采用了Ajax技术，也许你在该URL地址下面看到的和我在这个URL地址下看到的内容是不同的。这个和资源定位的初衷是相背离的。 AJAX不能很好支持移动设备。一些手持设备（如手机、PDA等）现在还不能很好的支持Ajax，比如说我们在手机的浏览器上打开采用Ajax技术的网站时，它目前是不支持的。 客户端过肥，太多客户端代码造成开发上的成本。编写复杂、容易出错 ；冗余代码比较多（层层包含js文件是AJAX的通病，再加上以往的很多服务端代码现在放到了客户端）；破坏了Web的原有标准。 jQuery中ajax的使用 在jQuery中ajax被封装成一个$.ajax函数，常用参数如下： 123456789101112131415161718192021222324252627$.ajax(&#123; type : \"GET or POST\", //请求类型 data : &#123; ... //需要提交的数据 &#125;, url : \" \" //数据提交的路径 beforeSend : function()&#123; ... //数据提交前所做的事情，一般用于数据的校验 return true; &#125;, success : function(result)&#123; //请求成功后的回调函数 if(result.success)&#123; //判断数据返回是否成功，result是后台返回的一个对象 ... &#125;else&#123; ... &#125; &#125;, error : function()&#123; //请求失败后的回调函数 ... &#125;&#125;); 实例——实现登录功能 js代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function dologin() &#123; /** 获取表单元素 floginacct——登录帐号 fusername——密码 ftype——用户类型 **/ var floginacct = $(\"#floginacct\"); var fuserpswd = $(\"#fuserpswd\"); var ftype = $(\"#ftype\"); $.ajax(&#123; type : \"POST\", data : &#123; //以json格式获取对应值 \"loginacct\" : floginacct.val(), \"userpswd\" : fuserpswd.val(), \"type\" : ftype.val() &#125;, url : \"$&#123;APP_PATH&#125;/doLogin.do\", //数据提交路径 beforeSend : function() &#123; //一般做表单校验 loadingIndex = layer.msg(\"处理中...\", &#123;icon:16&#125;); //弹层组件，类似于alert(\"...\") //对于表单而言不能用null进行判断，如果文本框什么都没有输入，获取的值是空串\"\" //$.trim(String) 去掉字符串前后两端的空格 if ($.trim(floginacct.val()) == \"\") &#123; layer.msg(\"用户帐户不能为空，请重新输入！\", &#123;time:2000, icon:5, shift:6&#125;, function() &#123; floginacct.val(\"\"); floginacct.focus(); &#125;); return false; &#125; if ($.trim(fuserpswd.val()) == \"\") &#123; layer.msg(\"用户密码不能为空，请重新输入！\", &#123;time:2000, icon:5, shift:6&#125;, function() &#123; floginacct.val(\"\"); floginacct.focus(); &#125;); return false; &#125; return true; &#125;, success : function(result) &#123; //&#123;\"success\":false,\"message\":\"登录失败！\"&#125; 或 &#123;\"success\":true&#125; layer.close(loadingIndex); if (result.success) &#123; window.location.href=\"$&#123;APP_PATH &#125;/main.htm\"; //数据请求成功并无异常 &#125;else &#123; //数据请求成功但抛异常 layer.msg(result.message, &#123;time:2000, icon:5, shift:6&#125; ); &#125; &#125;, error : function() &#123; //请求失败 layer.msg(\"登录失败！\", &#123;time:2000, icon:5, shift:6&#125;); &#125; &#125;); Controller层代码： 12345678910111213141516171819202122232425262728 //异步请求：处理请求后页面进行局部刷新，所以不会闪烁 //@ResponseBody 结合Jackson组件，将返回结果转换为字符串，将JSON串以流的形式返回给客户端. @ResponseBody @RequestMapping(\"/doLogin\") public Object doLogin( String loginacct, String userpswd, String type, HttpSession session) &#123; //AjaxResult是一个工具类，用于方便返回信息 AjaxResult result = new AjaxResult(); try &#123; Map&lt;String,Object&gt; paramMap = new HashMap&lt;String,Object&gt;(); paramMap.put(\"loginacct\", loginacct); paramMap.put(\"userpswd\", MD5Util.digest(userpswd)); paramMap.put(\"type\", type); User user = userService.login(paramMap); session.setAttribute(Const.LOGIN_USER, user); result.setSuccess(true); // &#123;\"success\":true&#125; &#125; catch (Exception e) &#123; result.setMessage(\"登录失败！\"); e.printStackTrace(); result.setSuccess(false); // &#123;\"success\":false,\"message\":\"登录失败！\"&#125; &#125; return result ;&#125; AjaxResult类： 12345678910111213141516171819202122public class AjaxResult &#123; private boolean success; private String message; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public boolean getSuccess() &#123; return success; &#125; public void setSuccess(boolean success) &#123; this.success = success; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/tags/java/"},{"name":"ajax","slug":"ajax","permalink":"http://flyingmcdonald.github.io/tags/ajax/"},{"name":"ssm","slug":"ssm","permalink":"http://flyingmcdonald.github.io/tags/ssm/"}]},{"title":"JVM加载类规则——双亲委派机制","slug":"JVM加载类规则——双亲委派机制","date":"2019-07-26T09:22:54.000Z","updated":"2019-07-26T10:05:01.115Z","comments":true,"path":"JVM加载类规则——双亲委派机制/","link":"","permalink":"http://flyingmcdonald.github.io/JVM加载类规则——双亲委派机制/","excerpt":"在JVM中，加载类，需要遵守双亲委派机制…","text":"在JVM中，加载类，需要遵守双亲委派机制… 双亲委派机制 在加载类时，应用类加载器首先执行加载，但不是立即加载，而是委派给父类加载器——扩展类加载器进行加载。 而扩展类加载器也不是立即加载，而是继续委派给父类加载器——启动类加载器进行加载。 如果启动类加载器能够加载，则直接加载使用；如果不能加载，则抛异常； 这时，扩展类加载器继续加载，如果能够加载，则直接加载使用；如果不能加载，则抛异常； 这时，应用类加载器继续加载，如果能够加载，则直接加载使用；如果不能加载，则抛异常；最终显示找不到类异常（ClassNotFoundException）。 加载器位置 启动类加载器：$JRE_HOME/classes目录（classes需手动创建） 扩展类加载器：$JRE_HOME/lib/classes目录（classes需手动创建） 应用类加载器：可存放到任意目录下 图解","categories":[{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://flyingmcdonald.github.io/tags/jvm/"}]},{"title":"静态包含,动态包含与注释","slug":"静态包含-动态包含与注释","date":"2019-07-26T08:21:45.000Z","updated":"2019-07-26T08:57:41.107Z","comments":true,"path":"静态包含-动态包含与注释/","link":"","permalink":"http://flyingmcdonald.github.io/静态包含-动态包含与注释/","excerpt":"在jsp页面中，静态包含与动态包含的区别以及HEML注释与JSP注释的区别","text":"在jsp页面中，静态包含与动态包含的区别以及HEML注释与JSP注释的区别 静态包含—&lt;%@ include page=”” %&gt; 静态包含：将所包含的页面内容加入页面一起编译，被包含的文件不会单独生成字节码文件。 动态包含—&lt;jsp:include page=”” /&gt; 动态包含：被包含的内容也会独立生成字节码文件。 注释 HTML注释：&lt;!-- --&gt;注释的内容参与编译，会生成到源码中。所以不能用html注释EL表达式和JSPL标签库。 JSP注释：&lt;%-- --%&gt;注释的内容不参与编译，不会生成到源码中。","categories":[{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/tags/java/"},{"name":"jsp","slug":"jsp","permalink":"http://flyingmcdonald.github.io/tags/jsp/"}]},{"title":"我惊了！原来部署项目的上下文路径可以这么短","slug":"我惊了！原来部署项目的上下文路径可以这么短","date":"2019-07-21T09:00:21.000Z","updated":"2019-07-21T11:44:32.243Z","comments":true,"path":"我惊了！原来部署项目的上下文路径可以这么短/","link":"","permalink":"http://flyingmcdonald.github.io/我惊了！原来部署项目的上下文路径可以这么短/","excerpt":"在开发javaweb项目时用http://localhost:端口号/项目名称/index.jsp这样巨长无比的上下文路径觉得不顺眼？配置一下，你就能用http://localhost愉快的测试代码啦 :)","text":"在开发javaweb项目时用http://localhost:端口号/项目名称/index.jsp这样巨长无比的上下文路径觉得不顺眼？配置一下，你就能用http://localhost愉快的测试代码啦 :) 环境 Eclipse 原理 Tomcat服务器在部署项目时将项目默认放在webapp目录下，而要省略上下文路径需要项目指定放在webapp/ROOT目录内. 一、从项目Properties面板中改路径 进行配置前需要先清理Tomcat服务器缓存，具体请Google一下 选中你的项目，右键打开properties 在搜索框搜索Web Project Settings 将Context root的内容改为”/“ OK！ 二、从配置文件中改路径 选中你的项目 点击右边的V形图标 点击Filters 取消选中.* resource，保存退出 展开你的项目，你能看见多了一个.settings文件夹，到里面找到org.eclipse.wst.common.component文件 找到org.eclipse.wst.common.component最底部的属性并做下面修改 1&lt;property name=\"context-root\" value=\"/\"/&gt; OK！","categories":[{"name":"其它","slug":"其它","permalink":"http://flyingmcdonald.github.io/categories/其它/"}],"tags":[{"name":"其它","slug":"其它","permalink":"http://flyingmcdonald.github.io/tags/其它/"}]},{"title":"SSM项目踩坑系列(一)","slug":"SSM项目踩坑系列-一","date":"2019-07-19T15:20:37.000Z","updated":"2019-07-21T11:57:45.180Z","comments":true,"path":"SSM项目踩坑系列-一/","link":"","permalink":"http://flyingmcdonald.github.io/SSM项目踩坑系列-一/","excerpt":"在经过一段时间对i3wm的折腾，我终于放弃了…于是从今天开始正式踏上ssm框架学习(踩坑)之路。:)","text":"在经过一段时间对i3wm的折腾，我终于放弃了…于是从今天开始正式踏上ssm框架学习(踩坑)之路。:) 环境 Tomcat 9 Maven 3.6.0 Eclipse 4.11.0 问题一 在开启Tomcat服务器遇到 class path resource [xxx/xxx] cannot be opened because it does not exist 怎么办？ 解决方法 此类问题一般都是由于目标文件位置与Spring的.xml配置文件内关于目标文件的ClassPath 不同所导致，所以解决此类问题只需要将ClassPath与目标文件路径一致即可。 例子 我遇到的情况是class path resource [config/jdbc.properties] cannot be opened because it does not exist，当时我查看Spring-context.xml时看到的是这个: 123&lt;bean id=\"propertyPlaceholderConfigurer\" class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"locations\" value=\"classpath:config/jdbc.properties\" /&gt;&lt;/bean&gt; 里面的内容需要我将jdbc.properties放入config文件夹中，可是我没有config文件夹呀，所以才会出现上述的异常。这里我新建一个config文件夹再将jdbc.properties移到里面，至此大功告成。 问题二 创建的maven项目如何部署到Tomcat服务器？ 解决方法 选中maven项目并按Alt+Enter打开properties先取消选中Dynamic Web Moudle点击Apply，然后再次选中Dynamic Web Moudle 注意Dynamic Web Moudle版本需保持一致 此时会出现这个:点它又会出现这个:然后将WebContent改为/src/main/webapp，记得要勾选下面的Generate web.xml deployment descriptor.至此大功告成.","categories":[{"name":"-java开发","slug":"java开发","permalink":"http://flyingmcdonald.github.io/categories/java开发/"}],"tags":[{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/tags/java/"},{"name":"ssm框架","slug":"ssm框架","permalink":"http://flyingmcdonald.github.io/tags/ssm框架/"},{"name":"踩坑系列","slug":"踩坑系列","permalink":"http://flyingmcdonald.github.io/tags/踩坑系列/"}]},{"title":"Hexo博客的搭建以及Next主题的优化","slug":"Hexo博客的搭建以及Next主题的优化","date":"2019-07-07T07:21:11.000Z","updated":"2019-07-13T09:36:07.900Z","comments":true,"path":"Hexo博客的搭建以及Next主题的优化/","link":"","permalink":"http://flyingmcdonald.github.io/Hexo博客的搭建以及Next主题的优化/","excerpt":"从博客搭建到选择主题以及优化主题已经过了一段时间了，在此用这篇文章来记录这段时间的学习(摸鱼)…","text":"从博客搭建到选择主题以及优化主题已经过了一段时间了，在此用这篇文章来记录这段时间的学习(摸鱼)… Hexo搭建安装Node.js 首先需要安装 Node.js : 将下载下来的压缩包进行解压: 1tar -xvf node-v12.6.0-linux-x64.tar.xz 确认一下nodejs下bin目录是否有node 和npm文件，如果有执行软连接，如果没有重新下载执行上边步骤… 建立软连接： 123sudo ln -s nodejs/bin/npm-cli.js /usr/local/bin/npmsudo ln -s nodejs/bin/npx-cli.js /usr/local/bin/npx 检验npm是否为全局变量，在终端中输入 npm –version 若出现版本号，则大功告成： 12npm --version6.9.0 由于Node的默认镜像源在国外，国内使用的话速度堪忧，所以换成淘宝源，之后我们就可以用cnpm代替npm了： 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装Hexo 确定Node.js安装无误后，接下来就可以安装Hexo了… 创建一个Blog目录，这个目录将是博客的根目录： 1mkdir Blog 进入Blog目录里运行以下命令： 1cnpm install -g hexo-cli //安装Hexo 初始化Hexo 12hexo initcnpm install 当Hexo初始化之后，Blog目录下会出现以下几个文件/目录： 123456Blog├── _config.yml //站点配置文件├── package.json //应用数据文件├── scaffolds //用于放置创建新博文时所需的模板├── source //站点源文件夹└── themes //主题文件夹 初始化之后就可以运行 hexo s 来在本地预览你的博客了 将Hexo部署到Github上 拥有一个github帐号并且创建一个名为username.github.io的仓库(username为你的github用户名且最好为小写)。 进入博客的根目录运行命令： 1cnpm install hexo-deployer-git --save //部署到github时用的插件 打开站点配置文件，找到下面代码并按下面的格式填入相关信息： 1234deploy: type: git repo: https://username:password@github.com/username/username.github.io branch: master 用以下命令将博客部署到github上： 123hexo clean //清空hexo数据hexo g //生成文件hexo d //部署到github 打开github.io仓库，如果看见hexo文件则一切OK 更换主题 虽然Hexo在初始化是会下载一个默认的主题，但由于这个主题并不美观，因此更换主题就是义不容辞的事情啦，所以下面会以更换nexT主题为例子来讲解如何更换主题。 下载nexT 12cd Bloggit clone https://github.com/theme-next/hexo-theme-next/ themes/next 更换nexT 打开站点配置文件，找到 theme 将内容改成： 1theme: next 在根目录运行： 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d nexT主题的优化 在更换主题后当然要根据自己的爱好进行一番折腾，这里提供了一些主题的优化配置。因为在next的配置文件名也是_config.yml，所以下面统一称next的配置文件为主题配置文件。设置语言 打开站点配置文件，找到 language 属性将其设为 zh-CN 设置头像 打开主题配置文件，找到avatar属性： 12345avatar: url: PATH //例：/Blog/source/blogImg/blog.png，PATH为:/blogImg/blog.png rounded: true or false //将头像显示为圆形 opacity: 0~1 //头像透明度 rotated: true or false //光标放在头像上时头像旋转 字数统计和阅读时间 进入博客根目录，运行命令： 1cnpm install hexo-symbols-count-time --save 打开主题配置文件，找到symbols_count_time属性： 1234567symbols_count_time: separated_meta: true or false //分割符号 item_text_post: true or false //文章字数 item_text_total: true or false //所有文章的总字数 awl: 2 //平均字符长度，en=4、cn=2 wpm: 275 //阅读速度 suffix: mins. //时间计量单位 详情描述 配置完后复制一份到站点配置文件 侧边栏显示阅读进度 打开主题配置文件，找到toc属性并如下配置： 123456toc: enable: true number: true wrap: true expand_all: true max_depth: 6 找到back2top属性并如下配置： 1234back2top: enable: true sidebar: true //返回侧边栏顶端 scrollpercent: true //阅读进度显示 评论功能——gitalk 进入Github主页，依次点击 头像-&gt;settings-&gt;Developer settings-&gt;OAuth Apps-&gt;New OAuth Apps 按照下图填入信息： 注册成功后将会获得一个 client_id 和 client_secret 因为nexT集成了gitalk，所以只需进入主题配置文件找到Gitalk属性填入相应配置即可： 12345678gitalk: enable: true or false github_id: //github用户名 repo: //储存评论用的仓库 client_id: //第三步的client_id client_secret: //第三步的client_secret admin_user: //管理员用户 language: //显示的语言，可用的值：en, es-ES, fr, ru, zh-CN, zh-TW 站点统计——不蒜子 nexT主题也集成了此功能，所以只需进入主题配置文件找到busuanzi属性填入相应配置即可： 12345678busuanzi_count: enable: true or false total_visitors: true or false //站点总的浏览人数 total_visitors_icon: //图标 默认为：user total_views: true or false //站点总的浏览量 total_views_icon: //图标，默认为：eye post_views: //单篇文章的浏览量 post_views_icon: //图标，默认为：eye 背景动画效果——canvas-nest 在nexT目录下运行命令： 1git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest 打开主题配置文件，找到canvas_nest属性并进行配置： 1234567canvas_nest: enable: true or false onmoblie: true or false //在移动端显示 color: \"122,122,122\" //颜色 opacity: 0~1 //透明度 zIndex: -1 //背景层数最好为-1 count: 150 //每行显示的数量 nexT主题内置了多个背景动画效果，但只能启用一个，无法多个并用 博文面板、侧边栏面板的透明度 若想要修改主题的样式，可以在 /next/source/css/_custom/custom.styl 文件里面写入你所需要改变的样式，此文件内的样式会自动覆盖默认样式。例如需要改变博文面板和侧边栏的透明度并添加阴影效果的代码如下： 123456789101112131415161718192021222324252627282930313233343536.content-wrap &#123; background: rgba(255, 255, 255, 0.2); &#125;.header-inner &#123; background: rgba(227, 230, 231, 0.5); border: 1px solid #E3E6E7; border-top: 0px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125;.sidebar-inner &#123; background: rgba(235, 235, 235, 0.5); border: 1px solid #EBEBEB; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125;.sidebar &#123; background: rgba(255, 255, 255, 0.0); &#125;.menu .menu-item a:hover, .menu-item-active a &#123; background: rgba(250, 250, 250, 0.6); border-bottom-color: rgba(250, 250, 250, 0.6); &#125;.post &#123; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 将文章末尾标签前面的’#’改成图标 打开主题配置文件，找到 tag_icon 属性将其改为 true 高级看板娘(说话,变装一应俱全) 在nexT目录下运行命令： 1git clone https://github.com/stevenjoezhang/live2d-widget.git source/live2d-widget 在 layout/_layout.swig 文件的 ** 标签里添加下面三行代码： 12345&lt;script src=\"https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js\"&gt;&lt;/script&gt;&lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css\"/&gt;&lt;script src=\"/live2d-widget/autoload.js\"&gt;&lt;/script&gt; 在主题配置目录里添加配置： 12live2d: enable: true live2d具体配置文件为 source/live2d-widget/ 里的 waifu.css、waifu-tip.css、waifu-tip.json文件。详情请参考live2d-widget :) Note提示块的使用 菜鸡感受…… 其实在一开始我是不知道还有Note提示块这种东西的，直到我看了xiaoding的某一篇博客…然后菜鸡的我花了一大段时间，通过百度、Google搜索各种蒙(菜的人连应该搜哪个关键字都不知道23333)终于让我蒙对了关键字，对！没有搜不到的结果，只有蒙不对的关键字 ：）后来的剧情就顺畅了许多，废话少说，上代码。 这是代码… 1234567891011121314151617181920212223&#123;% note default %&#125;default 提示块标签&#123;% endnote %&#125;&#123;% note primary %&#125;primary 提示块标签&#123;% endnote %&#125;&#123;% note success %&#125;success 提示块标签&#123;% endnote %&#125;&#123;% note info %&#125;info 提示块标签&#123;% endnote %&#125;&#123;% note warning %&#125;warning 提示块标签&#123;% endnote %&#125;&#123;% note danger %&#125;danger 提示块标签&#123;% endnote %&#125; 这是效果… default 提示块标签 primary 提示块标签 success 提示块标签 info 提示块标签 warning 提示块标签 danger 提示块标签 在主题配置文件中可以修改风格 12345678910111213# Note tag (bs-callout). note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: modern icons: true border_radius: 0 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0 参考文章：在hexo-NexT中插入note提示块next主题官方最全文档","categories":[{"name":"博客","slug":"博客","permalink":"http://flyingmcdonald.github.io/categories/博客/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://flyingmcdonald.github.io/tags/Linux/"},{"name":"博客","slug":"博客","permalink":"http://flyingmcdonald.github.io/tags/博客/"}]},{"title":"Linux下误将文件覆盖后的解决方法","slug":"Linux下误将文件覆盖后的解决方法","date":"2019-07-04T08:09:17.000Z","updated":"2019-07-06T12:55:19.714Z","comments":true,"path":"Linux下误将文件覆盖后的解决方法/","link":"","permalink":"http://flyingmcdonald.github.io/Linux下误将文件覆盖后的解决方法/","excerpt":"事件起因对重定向输出符号 &gt;(覆盖) 和 &gt;&gt;(从最后一行开始追加内容) 错误使用导致文件内容被覆盖(使用 mv 命令覆盖也适用)","text":"事件起因对重定向输出符号 &gt;(覆盖) 和 &gt;&gt;(从最后一行开始追加内容) 错误使用导致文件内容被覆盖(使用 mv 命令覆盖也适用) 解决方法经过查找资料后发现被覆盖的文件内容能够通过 grep 与 dd 这两个命令来找到 开始查找首先用 pwd 命令确认文件所在的目录(我的是在/home目录)， 用 fdisk -h 确认文件所在目录挂在哪个磁盘 123456789Filesystem Size Used Avail Use% Mounted onudev 3.9G 0 3.9G 0% /devtmpfs 787M 18M 770M 3% /run/dev/sda4 108G 50G 53G 49% /tmpfs 3.9G 63M 3.8G 2% /dev/shmtmpfs 5.0M 4.0K 5.0M 1% /run/locktmpfs 3.9G 0 3.9G 0% /sys/fs/cgroup/dev/sda3 512M 5.3M 507M 2% /boot/efitmpfs 787M 28K 787M 1% /run/user/1000 因为我用的是整个磁盘做的/目录(图方便)，所以可以看到我的/目录挂在 /dev/sda4 上。然后用使用 grep -a -b 命令在磁盘上通过文件内容中比较有代表性的字符串(字符串越长搜索结果越准确)来查找文件所在偏移的位置，并返回部分内容。比如： 1sudo grep -a -b 'echo \"YYFNB\"' /dev/sda4 grep中几个参数的解释-a用来把二进制文件当文本文件处理-b用来保证显示查找出的结果的偏移位置 其中 echo “YYFNB” 是我文件中比较有代表性的字符串，而 /dev/sda4 是我文件所在的磁盘位置。执行命令后过一会会出现搜索结果(一般查找的文件都会在前几个结果里)： 115938740228 : echo \"YYFNB\" 然后记住搜索结果中前面的偏移信息 15938740228 ，接着使用 dd 命令利用偏移信息直接从磁盘读取文件内容： 1dd if=/dev/sda4 count=1 skip=$(expr 15938740228 / 512) dd中使用的几个参数的解释count指明读取多少个数据块if指定读取源skip指定跳过多少个块（后面除以512是因为，skip是跳过ibs-sized blocks，而ibs默认大小为512） 注意事项：字符串一定要足够长以及有一定的单一性不然可能有多个搜索结果 参考文章https://my.oschina.net/u/573025/blog/378629","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://flyingmcdonald.github.io/tags/Linux/"},{"name":"文件管理","slug":"文件管理","permalink":"http://flyingmcdonald.github.io/tags/文件管理/"}]},{"title":"Markdown的基本使用方法","slug":"Markdown的基本使用方法","date":"2019-07-03T06:36:27.000Z","updated":"2019-07-13T08:59:14.194Z","comments":true,"path":"Markdown的基本使用方法/","link":"","permalink":"http://flyingmcdonald.github.io/Markdown的基本使用方法/","excerpt":"标题markdown的标题用#来表示,#的个数表示标题的级数:eg: 123456# 这是一个一级标题## 这是一个二级标题### 这是一个三级标题#### 这是一个四级标题##### 这是一个五级标题###### 这是一个六级标题","text":"标题markdown的标题用#来表示,#的个数表示标题的级数:eg: 123456# 这是一个一级标题## 这是一个二级标题### 这是一个三级标题#### 这是一个四级标题##### 这是一个五级标题###### 这是一个六级标题 字体 加粗 将要加粗的文字用两个**包起来 eg： 这是粗体 斜体 将要倾斜的文字用一个*包起来 eg: 这是斜体 加粗斜体 将要加粗倾斜的文字用三个***包起来 eg： 这是加粗斜体 删除线 将要加删除线的文字用两个~~包起来 eg：这是将要删除的文字 引用在引用的文字前面加上&gt;即可 eg： 这是引用的内容 这也是引用的内容 引中引 分割线用三个及其以上的-或*表示 图片语法： 12345![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title就是图片的标题，当鼠标移动到图片上时显示的内容。title可加可不加 eg： 超链接语法： 12345[超链接名](超链接地址 &quot;超链接title&quot;)超链接地址要加http://或https://title可加可不加 eg：baidu 列表1. 无序列表语法：无序列表用- + *任何一种都可以 12345- 列表内容+ 列表内容* 列表内容注：要加空格 2. 有序列表语法： 有序列表只需在文字前面加上1. 123456eg： 1. 列表内容 2. 列表内容 3. 列表内容注：序号和文字之间要加空格 表格1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 eg： 姓名 技能 表头 刘 关 张 代码语法：单行代码用一个反引号包起来多行代码用三个反引号包起来 流程图1234567st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op default 提示块标签 Text","categories":[],"tags":[{"name":"技术学习","slug":"技术学习","permalink":"http://flyingmcdonald.github.io/tags/技术学习/"}]}]}
{"meta":{"title":"Flying McDonald","subtitle":"事情总是太多,时间却又太少","description":"相信奇迹的人,本身就像奇迹<br>————麦当<星游记>","author":"Flying McDonald","url":"http://flyingmcdonald.github.io","root":"/"},"pages":[{"title":"文档","date":"2019-07-21T13:33:50.000Z","updated":"2019-10-22T17:13:43.928Z","comments":true,"path":"PDF/index.html","permalink":"http://flyingmcdonald.github.io/PDF/index.html","excerpt":"","text":"Java开发规范 Github命令"},{"title":"about","date":"2019-07-05T06:49:08.000Z","updated":"2019-07-05T06:49:08.697Z","comments":true,"path":"about/index.html","permalink":"http://flyingmcdonald.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-07-05T06:51:07.000Z","updated":"2019-07-07T06:03:50.969Z","comments":true,"path":"categories/index.html","permalink":"http://flyingmcdonald.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-05T06:50:17.000Z","updated":"2019-07-07T06:03:14.209Z","comments":true,"path":"tags/index.html","permalink":"http://flyingmcdonald.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Cookie——记住我","slug":"Cookie——记住我","date":"2019-12-29T15:41:11.000Z","updated":"2019-12-29T16:15:04.690Z","comments":true,"path":"Cookie——记住我/","link":"","permalink":"http://flyingmcdonald.github.io/Cookie——记住我/","excerpt":"","text":"HTML表单123456789101112131415&lt;form id=\"loginForm\" action=\"\" method=\"POST\"&gt; &lt;input type=\"text\" id=\"floginacct\" name=\"loginacct\" placeholder=\"请输入登录账号\" autofocus&gt; &lt;input type=\"password\" id=\"fuserpswd\" name=\"userpswd\" placeholder=\"请输入登录密码\" &gt; &lt;select id=\"ftype\" class=\"form-control\" name=\"type\"&gt; &lt;option value=\"member\"&gt;会员&lt;/option&gt; &lt;option value=\"user\"&gt;管理&lt;/option&gt; &lt;/select&gt; &lt;input id=\"rememberMe\" type=\"checkbox\" value=\"remember-me\"&gt; 记住我两周 &lt;a class=\"btn btn-lg btn-success btn-block\" onclick=\"dologin()\" &gt; 登录&lt;/a&gt;&lt;/form&gt; JQuery代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566layer为一个jquery插件，用于弹出提示框function dologin() &#123; //判断‘记住我两周’复选框有没有被选中，选中则flag=1 否则flag=0 var flag = $(\"#rememberMe\").prop(\"checked\") ? \"1\" : \"0\"; var floginacct = $(\"#floginacct\"); var fuserpswd = $(\"#fuserpswd\"); var ftype = $(\"#ftype\"); var loadingIndex = -1; $.ajax(&#123; type : \"POST\", data : &#123; \"loginacct\" : floginacct.val(), \"userpswd\" : fuserpswd.val(), \"type\" : ftype.val(), \"flag\" : flag &#125;, url : \"$&#123;APP_PATH&#125;/doLogin.do\", beforeSend : function() &#123; //一般做表单校验 loadingIndex = layer.msg(\"处理中...\", &#123;icon:16&#125;); //对于表单而言不能用null进行判断，如果文本框什么都没有输入，获取的值是空串\"\" //$.trim(String) 去掉字符串前后两端的空格 if ($.trim(floginacct.val()) == \"\") &#123; //若为空，则弹出提示并调用函数 layer.msg(\"用户帐户不能为空，请重新输入！\", &#123;time:2000, icon:5, shift:6&#125;, function() &#123; floginacct.val(\"\"); floginacct.focus(); &#125;); return false; &#125; if ($.trim(fuserpswd.val()) == \"\") &#123; layer.msg(\"用户密码不能为空，请重新输入！\", &#123;time:2000, icon:5, shift:6&#125;, function() &#123; floginacct.val(\"\"); floginacct.focus(); &#125;); return false; &#125; return true; &#125;, success : function(result) &#123; //&#123;\"success\":false,\"message\":\"登录失败！\"&#125; 或 &#123;\"success\":true&#125; layer.close(loadingIndex); if (result.success) &#123; //判断登录用户类型，不同用户跳转界面不一样 if(result.type == \"member\")&#123; window.location.href=\"$&#123;APP_PATH &#125;/member.htm\"; &#125;else&#123; window.location.href=\"$&#123;APP_PATH&#125;/main.htm\"; &#125; &#125;else &#123; layer.msg(result.message, &#123;time:2000, icon:5, shift:6&#125; ); &#125; &#125;, error : function() &#123; layer.msg(\"登录失败！\", &#123;time:2000, icon:5, shift:6&#125;); &#125; &#125;); &#125; Controller代码——将用户信息添加进Cookie12345678910111213141516171819202122232425262728293031323334353637383940 @ResponseBody@RequestMapping(\"/doLogin\")public Object doLogin( String loginacct, String userpswd, String type, String flag, HttpSession session, HttpServletResponse response) &#123; AjaxResult result = new AjaxResult(); try &#123; Map&lt;String,Object&gt; paramMap = new HashMap&lt;String,Object&gt;(); paramMap.put(\"loginacct\", loginacct); paramMap.put(\"userpswd\", MD5Util.digest(userpswd)); //将密码进行md5加密然后存进hashMap中 if(\"user\".equals(type)) &#123; //判断用户类型 User user = userService.login(paramMap); //判断用户帐号密码是否正确 if(\"1\".equals(flag)) &#123; //将信息写入字符串中然后传进Cookie里 String cookieInfo = \"loginacct=\"+user.getLoginacct()+\"&amp;userpswd=\"+user.getUserpswd()+\"&amp;type=\"+type; Cookie cookie = new Cookie(\"cookieInfo\", cookieInfo); //指定客户端应向其返回cookie的cookie的路径。 cookie.setPath(\"/\"); //设置cookie最大存活时间 cookie.setMaxAge(2*7*24*60*60); //将cookie添加到响应 response.addCookie(cookie); &#125; result.setType(type); result.setSuccess(true); &#125; &#125; catch (Exception e) &#123; result.setMessage(\"登录失败！\"); e.printStackTrace(); result.setSuccess(false); // &#123;\"success\":false,\"message\":\"登录失败！\"&#125; &#125; return result ;&#125; Controller代码——获取Cookie实现自动登录12345678910111213141516171819202122232425262728293031323334 @RequestMapping(\"/login\")public String login (HttpServletRequest request, HttpSession session) &#123; Cookie[] cookieList = request.getCookies(); if(cookieList == null) &#123; //若客户端没有Cookie，则跳转到登录界面 return \"login\"; &#125;else &#123; for (Cookie cookie : cookieList) &#123; //遍历cookie数组 if(cookie.getName().equals(\"cookieInfo\")) &#123; //查找cookie String loginInfo = cookie.getValue(); //获取cookie的值 String[] loginData = loginInfo.split(\"&amp;\"); //根据&amp;来分割数据信息 String loginacct = loginData[0].split(\"=\")[1]; //获取用户帐号 String userpswd = loginData[1].split(\"=\")[1]; //获取用户密码 String type = loginData[2].split(\"=\")[1]; //获取用户类型 //将loginacct, userpswd加入hashMap中 Map&lt;String,Object&gt; paramMap = new HashMap&lt;String,Object&gt;(); paramMap.put(\"loginacct\", loginacct); paramMap.put(\"userpswd\", userpswd); if(type.equals(\"user\")) &#123; User user = userService.login(paramMap); //验证用户帐号密码 return \"redirect:main.htm\"; //跳转到指定界面 &#125;else if(type.equals(\"member\"))&#123; Member member = memberService.queryMember(paramMap);//验证用户帐号密码 return \"redirect:member.htm\"; //跳转到指定界面 &#125;else &#123; return \"login\"; &#125; &#125; &#125; &#125; return \"login\";&#125;","categories":[{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/tags/java/"},{"name":"springMVC","slug":"springMVC","permalink":"http://flyingmcdonald.github.io/tags/springMVC/"}]},{"title":"Activiti5-显示流程图","slug":"Activiti5-显示流程图","date":"2019-12-28T15:53:35.000Z","updated":"2019-12-28T16:16:16.275Z","comments":true,"path":"Activiti5-显示流程图/","link":"","permalink":"http://flyingmcdonald.github.io/Activiti5-显示流程图/","excerpt":"","text":"前期准备 部署一个Activiti5流程 前端界面，红色框处为显示流程图的按钮 按钮处代码，${APP_PATH} 为项目的ContextPath： 显示流程图的界面 showImg.jsp，以及里面一些关键代码。${param.id} 为ER表达式，拿到的为传入的流程定义时的Id值 代码实现Controller 层代码： 1234567891011121314151617181920212223242526//做一个跳转，跳转到显示流程图的界面 @RequestMapping(\"/showImg\") public String showImg() &#123; return \"process/showImg\"; &#125; @RequestMapping(\"/doShowImg\") @ResponseBody public void doShowImg(String id, HttpServletResponse response) throws IOException &#123; //根据流程定义id获取流程定义对象 ProcessDefinition processDefinition = repositoryService.getProcessDefinition(id); //获取流程图的资源名称 String diagramResourceName = processDefinition.getDiagramResourceName(); //获取流程图的输入流实例 InputStream resourceAsStream = repositoryService.getResourceAsStream(processDefinition.getDeploymentId(), diagramResourceName); //获取输出流实例 ServletOutputStream outputStream = response.getOutputStream(); //将输入流copy到输出流 IOUtils.copy(resourceAsStream, outputStream); &#125;","categories":[{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/categories/java/"}],"tags":[{"name":"Activiti5","slug":"Activiti5","permalink":"http://flyingmcdonald.github.io/tags/Activiti5/"},{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/tags/java/"},{"name":"ssm","slug":"ssm","permalink":"http://flyingmcdonald.github.io/tags/ssm/"}]},{"title":"Activiti5——流程框架","slug":"Activiti5——流程框架","date":"2019-12-17T09:15:06.000Z","updated":"2019-12-17T18:22:05.955Z","comments":true,"path":"Activiti5——流程框架/","link":"","permalink":"http://flyingmcdonald.github.io/Activiti5——流程框架/","excerpt":"","text":"Activiti5框架的由来JBPM，全称是 Java Business Process Management(业务流程管理系统) ，它是覆盖了业务流程管理、工作流、服务协作等领域的一个开源的、灵活的、易扩展流程语言框架。JBPM是开源项目。JBPM在2004年10月18日，发布了2.0版本，并在同一天加入了JBoss，成为JBoss企业中间件平台的一个组成部分，它的名称也改为JBoss JBPM。在 JBPM4 之后，公司内部对于软件的规划发生了分歧，所以当时的项目架构师脱离了原来的公司，加入新公司后。改了名称为 Activiti5。JBPM 采用 Hibernte (JBPM核心发生了很大的变化)Activiti5 采用 Mybatis (Mybatis3， 1和2都叫做iBatis) Activiti5框架Eclipse Activiti5插件安装 打开Eclipse 点击Help 点击Install New Software 点击Add Name：Activiti BPMN 2.0 desiger Location：http://www.activiti.org/designer/update 引擎和服务接口 ProcessEngine： 这个类是Activiti5的核心，所有的服务都需要通过 ProcessEngine 来创建，该类是 线程安全 的Activiti5持久化层采用的是 Mybatis ，这样移植性好。Activiti5 主要包含 7个Service ，这些Service都是通过 ProcessEngine 创建。 RepositoryService(持久化服务)： 与数据库进行交互的 RuntimeService(运行时服务)： 与运行流程有关 FormService(表单服务)： 与流程中的表单信息有关 IdentityService(身份信息)： 流程中的标识信息 TaskService(任务服务)： 与流程中的每一个步骤有关 HistoryService(历史信息)： 查看历史的流程步骤 ManagementService(管理定时任务)： 在固定的时间点完成固定的任务 23张表在你使用Activiti5时会在数据库中创建23张数据表，Activiti5使用到的表都是 ACT_ 开头的。 ACT_RE_* ：RE 表示 repository(存储) ，RepositoryService接口所操作的表，带此前缀的表包含的是静态信息。如：流程定义，流程的资源(图片，规划等)。 ACT_RU_* ：RU 表示 runtime，运行时表-RuntimeService。这是运行时的表存储着流程的变量，用户任务，变量，职责(job) 等运行时的数据。Activiti5之存储实例执行期间的运行时数据，当流程实例结束时，将删除这些记录。这就保证了这些运行时的表小且快。 ACT_ID_* ：ID表示identity(组织机构)，IdentityService接口所操作的表。用户记录，流程中使用到的用户和组。这些表包含标识的信息，如：用户，用户组等等。 ACT_HI_* ：HI表示 history，历史数据表，HistoryService。就是这些表包含着流程执行的历史相关数据。如：结束的流程实例，变量，任务等等。 ACT_GE_*：全局通用数据及设置(general)，各种情况都使用的数据。 序号 表名 说明 1 act_ge_bytearray 二进制数据表 2 act_ge_property 属性数据表存储整个流程引擎级别的数据，初始化表结构时，会默认插入三条数据 3 act_hi_actinst 历史节点表 4 act_hi_attachme 历史附件表 5 act_hi_comment 历史意见表 6 act_hi_identitylink 历史流程人员表 7 act_hi_detail 历史详情表，提供历史变量的查询 8 act_hi_procinst 历史流程实例表 9 act_hi_taskinst 历史任务实例表 10 act_hi_varinst 历史变量表 11 act_id_group 用户组信息表 12 act_id_info 用户扩展表 13 act_id_membership 用户与用户组对应信息表 14 act_id_user 用户信息表 15 act_re_deployment 部署信息表 16 act_re_model 流程设计模型部署表 17 act_re_procdef 流程定义数据表 18 act_ru_event_subscr throwEvent、catchEvent时间监听信息表 19 act_ru_execution 运行时流程执行实例表 20 act_ru_identitylink 运行时流程人员表，主要存储任务节点与参与者的相关信息 21 act_ru_job 运行时定时任务数据表 22 act_ru_task 运行时任务节点表 23 act_ru_variable 运行时流程变量数据表 CODE创建23张表Activiti5配置文件： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:jee=\"http://www.springframework.org/schema/jee\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.1.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.1.xsd\"&gt; &lt;bean id=\"processEngineConfiguration\" class=\"org.activiti.spring.SpringProcessEngineConfiguration\"&gt; //加载数据源，连接数据库-------在SpringMVC配置文件中找ID为dataSource的Bean &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; //加载事务管理器 &lt;property name=\"transactionManager\" ref=\"transactionManager\" /&gt; &lt;property name=\"databaseSchemaUpdate\" value=\"true\" /&gt; &lt;property name=\"jobExecutorActivate\" value=\"true\" /&gt; &lt;property name=\"labelFontName\" value=\"宋体\" /&gt; &lt;property name=\"activityFontName\" value=\"宋体\" /&gt; &lt;property name=\"customFormTypes\"&gt; &lt;list&gt; &lt;bean class=\"org.activiti.explorer.form.UserFormType\"/&gt; &lt;bean class=\"org.activiti.explorer.form.ProcessDefinitionFormType\"/&gt; &lt;bean class=\"org.activiti.explorer.form.MonthFormType\"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; //核心工厂bean &lt;bean id=\"processEngine\" class=\"org.activiti.spring.ProcessEngineFactoryBean\" destroy-method=\"destroy\"&gt; &lt;property name=\"processEngineConfiguration\" ref=\"processEngineConfiguration\" /&gt; &lt;/bean&gt; &lt;bean id=\"repositoryService\" factory-bean=\"processEngine\" factory-method=\"getRepositoryService\" /&gt; &lt;bean id=\"runtimeService\" factory-bean=\"processEngine\" factory-method=\"getRuntimeService\" /&gt; &lt;bean id=\"taskService\" factory-bean=\"processEngine\" factory-method=\"getTaskService\" /&gt; &lt;bean id=\"historyService\" factory-bean=\"processEngine\" factory-method=\"getHistoryService\" /&gt;&lt;/beans&gt; 创建表： 123456//这段代码执行时将会在数据库中创建23张数据表//加载activiti配置文件和springMVC配置文件并拿到ioc容器ApplicationContext ioc = new ClassPathXmlApplicationContext(\"spring/spring-*.xml\");//从ioc容器中获取processEngine引擎ProcessEngine processEngine = (ProcessEngine)ioc.getBean(\"processEngine\"); 部署流程画工作流图：部署流程之前，得先画好工作流图。怎么画工作流图 部署： 123456789//部署流程定义 @Test public void test02() &#123; //获取RepositoryService接口对象 RepositoryService repositoryService = processEngine.getRepositoryService(); //部署工作流图 repositoryService.createDeployment().addClasspathResource(\"MyProcess.bpmn\").deploy(); &#125; 部署之后，数据表中的： act_ge_bytearray act_re_deployment act_re_procdef 这三张表会有数据生成，具体的可以自己去康康 流程定义查询从 act_re_procdef 表查询定义流程的信息 123456789101112131415//流程定义查询@Test public void test03() &#123; RepositoryService repositoryService = processEngine.getRepositoryService(); //获得流程定义查询的一个实例 ProcessDefinitionQuery processDefinitionQuery = repositoryService.createProcessDefinitionQuery(); //获得所有流程定义的一个集合 List&lt;ProcessDefinition&gt; list = processDefinitionQuery.list(); for (ProcessDefinition processDefinition : list) &#123; System.out.println(\"id=\"+processDefinition.getId()); System.out.println(\"key=\"+processDefinition.getKey()); System.out.println(\"name=\"+processDefinition.getName()); System.out.println(\"version=\"+processDefinition.getVersion()); &#125; &#125; 创建流程实例12345678910111213//创建流程实例@Test public void test04() &#123; //获取流程定义 ProcessDefinition processDefinition = processEngine.getRepositoryService().createProcessDefinitionQuery().latestVersion().singleResult(); //获取正在运行的服务 RuntimeService runtimeService = processEngine.getRuntimeService(); //获取流程实例 ProcessInstance processInstance = runtimeService.startProcessInstanceById(processDefinition.getId()); System.out.println(\"processInstance：\"+processInstance); &#125; 执行代码后： act_hi_actinst： 历史活动的实例表表 act_hi_procinst： 历史的流程实例表 act_hi_taskinst： 历史的任务实例表 act_ru_execution： 正在运行的任务表 act_ru_task ： 正在运行的任务数据表 这四张表会有数据的变动 创建任务查询实例画工作流图并给属性赋值下图的意思是将组长审批任务交给lisi处理。经理审批亦是如此 任务查询代码 12345678910111213141516//创建任务查询实例 @Test public void test05() &#123; //得到TaskService接口 TaskService taskService = processEngine.getTaskService(); //创建任务查询实例 TaskQuery createTaskQuery = taskService.createTaskQuery(); //查询lisi的所有任务 List&lt;Task&gt; list = createTaskQuery.taskAssignee(\"lisi\").list(); for (Task task : list) &#123; //打印任务Id，任务名称 System.out.println(\"id=\"+task.getId()); System.out.println(\"name=\"+task.getName()); taskService.complete(task.getId()); &#125; &#125; 历史实例查询123456789101112//历史实例查询 @Test public void test06() &#123; //获取HistoryService接口对象 HistoryService historyService = processEngine.getHistoryService(); //创建历史流程实例查询实例 HistoricProcessInstanceQuery historicProcessInstanceQuery = historyService.createHistoricProcessInstanceQuery(); //查询流程实例Id为304的实例 HistoricProcessInstance historicProcessInstance = historicProcessInstanceQuery.processInstanceId(\"304\").finished().singleResult(); System.out.println(\"历史实例：\"+historicProcessInstance); &#125; 任务领取画工作流图并给属性赋值下图意思是将组长审批这个任务分发给一个组名为yyf的小组，然后由小组内的成员领取任务。 任务领取实例代码 123456789101112131415161718192021222324252627//领取任务 @Test public void test07() &#123; TaskService taskService = processEngine.getTaskService(); TaskQuery taskQuery = taskService.createTaskQuery(); //获取yyf小组所有的任务量 List&lt;Task&gt; list = taskQuery.taskCandidateGroup(\"yyf\").list(); //查询张三的领取任务前的任务数量 long count = taskQuery.taskAssignee(\"zhangsan\").count(); System.out.println(\"zhangsan领取前的任务数量=\"+count); for (Task task : list) &#123; System.out.println(\"id:\"+task.getId()); System.out.println(\"name:\"+task.getName()); //指定zhangsan领取任务 taskService.claim(task.getId(), \"zhangsan\"); &#125; System.out.println(\"--------------------------------------\"); taskQuery = taskService.createTaskQuery(); //查询zhangsan领取任务后的任务量 List&lt;Task&gt; count2 = taskQuery.taskAssignee(\"zhangsan\").list(); for (Task task : count2) &#123; System.out.println(\"id=\"+task.getId()); System.out.println(\"name\"+task.getName()); &#125; System.out.println(\"zhangsan领取后的任务数量=\"+count2.size()); &#125; 流程变量画工作流图并给属性赋值下图意思是将组长审批任务的处理人设为变量${tl}，然后在代码里将该变量赋值 流程变量赋值 1234567891011//设置流程变量 //当设置了流程变量时，启动流程时需要给流程变量赋值，否则会报错 @Test public void test08() &#123; ProcessDefinition processDefinition = processEngine.getRepositoryService().createProcessDefinitionQuery().latestVersion().singleResult(); RuntimeService runtimeService = processEngine.getRuntimeService(); Map&lt;String, Object&gt; variables = new HashMap&lt;String, Object&gt;(); variables.put(\"tl\",\"zhangsan\"); //通过定义的流程Id启动流程实例 runtimeService.startProcessInstanceById(processDefinition.getId(), variables); &#125; 排他网关——决策画工作流图并给属性赋值 下图为排他网关的图片 下图为判定请假天数所需走的流程，注：条件表达式是在连接排他网关的连接线上 排他网关代码 1234567891011121314151617181920212223//排他网关 @Test public void test09() &#123; ProcessDefinition processDefinition = processEngine.getRepositoryService().createProcessDefinitionQuery().latestVersion().singleResult(); RuntimeService runtimeService = processEngine.getRuntimeService(); Map&lt;String, Object&gt; variables = new HashMap&lt;String, Object&gt;(); variables.put(\"days\",\"5\"); ProcessInstance processInstance = runtimeService.startProcessInstanceById(processDefinition.getId(), variables); System.out.println(\"processInstance\"+processInstance); &#125; @Test public void test091() &#123; TaskService taskService = processEngine.getTaskService(); TaskQuery taskQuery = taskService.createTaskQuery(); //lisi为组长审批的处理者 List&lt;Task&gt; list = taskQuery.taskAssignee(\"lisi\").list(); for (Task task : list) &#123; //完成任务 taskService.complete(task.getId()); &#125; &#125; 并行网关——会签画工作流图并给属性赋值 下图为并行网关图片 下图为并行网关工作流图，需要`项目经理审批`和`财务经理审批`一起通过后流程才会结束 并行网关代码 12345678910111213141516171819202122232425//并行网关 @Test public void test10() &#123; ProcessDefinition processDefinition = processEngine.getRepositoryService().createProcessDefinitionQuery().latestVersion().singleResult(); RuntimeService runtimeService = processEngine.getRuntimeService(); ProcessInstance processInstance = runtimeService.startProcessInstanceById(processDefinition.getId()); System.out.println(\"processInstance=\"+processInstance); &#125; @Test public void test101() &#123; TaskService taskService = processEngine.getTaskService(); TaskQuery taskQuery = taskService.createTaskQuery(); List&lt;Task&gt; list = taskQuery.taskAssignee(\"lisi\").list(); List&lt;Task&gt; list2 = taskQuery.taskAssignee(\"zhangsan\").list(); //项目经理与财务经理一起通过，流程才能结束 for (Task task : list) &#123; taskService.complete(task.getId()); &#125; for (Task task : list2) &#123; taskService.complete(task.getId()); &#125; &#125; 包含网关——排他+并行画工作流图并给属性赋值 下图为包含网关图片 下图为包含网关工作流图，当条件满足下图中的条件表达式时，才会走任务 包含网关代码 1234567891011121314151617181920212223242526272829303132333435363738@Test public void test11() &#123; ProcessDefinition processDefinition = processEngine.getRepositoryService().createProcessDefinitionQuery().latestVersion().singleResult(); RuntimeService runtimeService = processEngine.getRuntimeService(); Map&lt;String, Object&gt; variables = new HashMap&lt;String, Object&gt;(); //给定变量值 variables.put(\"days\", \"2\"); variables.put(\"cost\", \"4000\"); ProcessInstance processInstance = runtimeService.startProcessInstanceById(processDefinition.getId(),variables); System.out.println(\"processInstance=\"+processInstance); &#125; @Test public void test111() &#123; TaskService taskService = processEngine.getTaskService(); TaskQuery taskQuery = taskService.createTaskQuery(); //zhangsan为项目经理审批处理人，lisi为财务经理审批处理人 //查询zhangsan的任务 List&lt;Task&gt; list = taskQuery.taskAssignee(\"zhangsan\").list(); for (Task task : list) &#123; System.out.println(\"id=\"+task.getId()); System.out.println(\"name=\"+task.getName()); System.out.println(\"assignee=\"+task.getAssignee()); //完成任务 taskService.complete(task.getId()); &#125; //查询lisi的任务 List&lt;Task&gt; list2 = taskQuery.taskAssignee(\"lisi\").list(); for (Task task : list2) &#123; System.out.println(\"id=\"+task.getId()); System.out.println(\"name=\"+task.getName()); System.out.println(\"assignee=\"+task.getAssignee()); //完成任务 taskService.complete(task.getId()); &#125; &#125;","categories":[{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/tags/java/"}]},{"title":"git命令基本操作","slug":"git命令基本操作","date":"2019-10-22T14:28:33.000Z","updated":"2019-10-23T03:32:47.110Z","comments":true,"path":"git命令基本操作/","link":"","permalink":"http://flyingmcdonald.github.io/git命令基本操作/","excerpt":"git的一些基本命令操作以及遇到的一些坑。","text":"git的一些基本命令操作以及遇到的一些坑。 Git是什么玩意儿 用官话讲：Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。与常用的版本控制工具CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 用人话讲：Git是一个让你自由管理软件的神器，让你较为轻松的管理软件版本，节省时间。搭配着github使用，更是可以在同性面前出类拔萃脱颖而出（都是些废话，轻喷） Github是什么玩意儿 Github是基于git的全球最大的代码托管平台（同性交友平台），里面有着各类程序员头发的结晶（code）。你可以在github看别人的代码然后提升自己的编码水平，也可以与同行一起讨论技术问题，里面的人个个都是人才，说话又好听，哦哟我超喜欢github的。当然，你也可以加入他们成为百万开源社区大军中的一员。如果你想要了解更多关于github的资料，Click here。 我该怎么将我的项目托管到Github上呢 注册一个github帐号，地址在 Here 安装git工具，这里是Debian安装的方法sudo apt install git（其它系统自行百度git安装教程） 创建一个仓库（Create a new repository），进入你的github个人主页并进行观察 点击New点击start a project点击New 点击之后，看到这个 按照步骤通常是：仓库名（Repository name）——&gt;仓库描述（Description可选）——&gt;初始化一个README（Initialize this repository with a README创建README 可以让别人更好地了解你的项目）——&gt;创建仓库（Create repository） 进入你的项目根目录下运行git init初始化一个本地git仓库，之后在你的项目根目录会新增一个.git文件夹 运行git add .将你的项目里的所有文件加入本地git仓库，然后git commit -m &#39;一些描述&#39;合并提交。 git remote add origin xxxxx连接远程github上的仓库，这里的xxxx有三种情况： ssh协议：git@github.com:username/repository_name.git git协议：git://github.com/username/repository_name.git https协议：https://github.com/username/repository_name.git 这三种协议里面用的比较多的为ssh协议，因为速度比较快而且可以免密码传输，但是需要配置公钥。在后面会具体讲讲怎么配置公钥。现在我们先用https协议吧，git remote add origin https://github.com/username/repository.git。 如果你在创建仓库的时候初始化了README文件，那么你可能需要先运行git pull origin master命令来从远端仓库把README文件下载到项目目录。但仅仅靠git pull origin master可能会出现状况，比如 12! [rejected] master -&gt; master (non-fast forward)... 如果出现上述问题，则需要加个参数git pull origin master --allow-unrelated-histories进行远端和本地的同步（这是一个坑）。然后重新git add .和git commit OK！走到这一步，我们就能愉快的托管代码了。第一次提交需要git push -u origin master，之后就只要git push就好了。可是这样的话我们每次提交都要输入帐号和密码极其麻烦，所以后面我会讲讲如何 设置全局帐号和密码 这是后面1. SSH协议配置公钥 首先下载ssh，这里还是以Debian为例子sudo apt install ssh 在你的家目录运行ssh-keygen -t rsa -C &quot;your email&quot;然后疯狂回车 接着你的家目录会新增一个.ssh目录，里面有 id_rsa 和 id_rsa.pub 文件。然后打开github个人主页，找到 setting点击New SSH KeyTitle随便写，Key里面填你id_rsa.pub里面的东西。然后运行ssh -T git@github.com，如果出现这个，OK恭喜你成功了。这时候你就可以轻轻松松的不用输入帐号密码了。 2. HTTPS协议配置全局帐号密码 运行git config --global user.name &quot;your username&quot; 运行git config --global user.password &quot;your password&quot; 运行git config --global user.email &quot;your email&quot; 运行git config --global credential.helper store OK！接下来你只需要在你的项目内输入一次帐号密码即可。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://flyingmcdonald.github.io/categories/Linux/"},{"name":"git","slug":"Linux/git","permalink":"http://flyingmcdonald.github.io/categories/Linux/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://flyingmcdonald.github.io/tags/git/"}]},{"title":"简历","slug":"简历","date":"2019-10-22T14:28:33.000Z","updated":"2019-11-11T09:05:42.516Z","comments":true,"path":"简历/","link":"","permalink":"http://flyingmcdonald.github.io/简历/","excerpt":"个人简历","text":"个人简历 个人资料NAME: 杨云飞 Phone: 18870402437 QQ: 1476211809 Mail: 1476211809@qq.com WeChat: yyf66566 Blog: https://flyingmcdonald.github.io Github: https://github.com/FlyingMcDonald技能点开发方面 熟悉Java开发，并用Java编写了一个屏幕取色器 ScreenColorCapture 的程序。 了解Linux常见命令，以及Linux下的各种服务器的搭建与配置，能自主编写一些shell脚本。 了解一些常用的Java框架，比如：SSM、SpringBoot。能运用其搭建简单的网站，熟练使用Mysql数据库，能够将RBAC权限模型运用到实际应用中。 能使用Git进行协同开发。 常用Eclipse、Idea、VSCode进行开发。 网络安全方面 了解OWASP Top 10中的一些风险的原理以及利用方法。 熟悉HTTP协议，会一些常见漏洞挖掘。 能使用Burp Suit、nmap、sqlmap、AntSword、Angry Ip Scaner等渗透工具。 能对Java和PHP代码进行审计。 了解Linux常见命令，以及Linux下的各种服务器的搭建与配置，能自主编写一些shell脚本。 其它方面 良好的自学能力，在大学期间自学Linux系统，并且一直以Linux为主系统使用至今。 良好的文档阅读能力，在折腾Linux的时候经常查看技术文档。 对未知技术充满热情，折腾力十足，能运用搜索引擎独立解决技术上的问题。 能高效地进行团队交流、协作。 校园经历2018.9 - 2019.7 &nbsp;&nbsp;&nbsp; 九江学院信息安全团队 - 负责人 在大学期间保持本专业成绩前茅的同时自学了Linux、Web渗透等技能。 在大一被学校信息安全团队管理员相中成为其中一员，并在大二担任负责人。 对大一新生进行信息安全普及以及技术培训，获得了学校及老师们的支持与肯定。 带队参加2019年江西省大学生信息安全技术大赛并取得第八名的成绩。 教育经历2017.9 - 2020.7 &nbsp;&nbsp;&nbsp; 九江学院 - 软件技术 成绩排名：前 10 主修课程：计算机网络、操作系统、Java高级应用、PHP开发、HTML与CSS、python游戏编程、动态网站搭建、C语言从入门到精通","categories":[{"name":"简历","slug":"简历","permalink":"http://flyingmcdonald.github.io/categories/简历/"}],"tags":[{"name":"简历","slug":"简历","permalink":"http://flyingmcdonald.github.io/tags/简历/"}]},{"title":"i3折腾——rofi的奇怪图标","slug":"i3折腾——rofi的奇怪图标","date":"2019-10-20T16:28:30.000Z","updated":"2019-10-22T15:27:43.464Z","comments":true,"path":"i3折腾——rofi的奇怪图标/","link":"","permalink":"http://flyingmcdonald.github.io/i3折腾——rofi的奇怪图标/","excerpt":"今天解决了我用rofi后发现的一个关于XTerm terminal图标的问题，虽然过程走了一大段弯路，但总归拐回来了。仅以此文章记录问题的解决步骤：）","text":"今天解决了我用rofi后发现的一个关于XTerm terminal图标的问题，虽然过程走了一大段弯路，但总归拐回来了。仅以此文章记录问题的解决步骤：） 问题起因在安装配置完rofi后，进入window mode时发现XTerm图标显示不出来，但在drun mode下却可以显示图标。图示： 尝试解决在/usr/share/applications/debian-xterm.desktop(各个Linux发行版的XTerm的.desktop名称可能不尽相同)中发现 Icon=mini.xterm 但没有给出图标的路径。这里我用find /usr -name mini.xterm*命令去搜索/usr目录中以mini.xterm开头的文件，发现了两条路径下包含 mini.xterm.svg文件，分别为/usr/local/share/icons/hicolor/scalable/apps/mini.xterm.svg和/usr/share/icons/hicolor/scalable/apps/mini.xterm.svg。条路径都尝试一下发现/usr/share/icons/hicolor/scalable/apps/mini.xterm.svg为Icon=mini.xterm中的mini.xterm(具体怎么试的无非是把每条路经中的mini.xterm.svg移到另外的地方，然后查看drun mode下XTerm是否还显示图标)。图标位置虽然找到了，但依然解决不了问题，似乎Xterm在window mode的图标与Icon所指图标不一样。GG :( 最终解决方案在经过超长超长时间的折腾后，我决定debug rofi，看看它会给我什么信息反馈。 123456# drun modeG_MESSAGES_DEBUG=\"Helpers.IconFetcher\" rofi -show drun -show-icons -filter \"xterm\"(process:7781): Helpers.IconFetcher-DEBUG: 01:39:25.209: Query: mini.xterm(19)(process:7781): Helpers.IconFetcher-DEBUG: 01:39:25.209: starting up icon fetching thread.(process:7781): Helpers.IconFetcher-DEBUG: 01:39:25.210: found icon mini.xterm(19): ~/.local/share/icons/hicolor/scalable/apps/mini.xterm.svg 1234567# window modeG_MESSAGES_DEBUG=\"Helpers.IconFetcher\" rofi -show window -show-icons -filter \"xterm\"(process:7831): Helpers.IconFetcher-DEBUG: 01:41:01.602: Query: XTerm(19)(process:7831): Helpers.IconFetcher-DEBUG: 01:41:01.603: starting up icon fetching thread.(process:7831): Helpers.IconFetcher-DEBUG: 01:41:01.606: failed to get icon XTerm(19): n/a(process:7831): Helpers.IconFetcher-DEBUG: 01:41:01.608: Query: XTerm(19) 从上面可以看出一个关键信息Query:mini.xterm和Query:XTerm，我已经知道了mini.xterm是drun mode中显示的图标。此时我作出了一个假设，会不会XTerm也是一个图标名称。对着这个假设，我做了一个实验，在/usr/share/icons/hicolor/scalable/apps/内创建了一个XTerm.svg结果还真就成了:D虽然是一个小问题，但喜悦的心情是难以抑制的，这可能就是Linuxer的特别待遇吧。碰到问题多思考，多尝试，多假设，万一猜对了呢。:D","categories":[{"name":"Linux","slug":"Linux","permalink":"http://flyingmcdonald.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://flyingmcdonald.github.io/tags/Linux/"},{"name":"rofi","slug":"rofi","permalink":"http://flyingmcdonald.github.io/tags/rofi/"},{"name":"i3wm","slug":"i3wm","permalink":"http://flyingmcdonald.github.io/tags/i3wm/"}]},{"title":"样式命名参考","slug":"样式命名参考","date":"2019-09-12T02:06:38.000Z","updated":"2019-09-12T02:50:21.307Z","comments":true,"path":"样式命名参考/","link":"","permalink":"http://flyingmcdonald.github.io/样式命名参考/","excerpt":"","text":"页面功能 命名参考 页面功能 命名参考 页面功能 命名参考 容器 wrap/container/box 头部 header 加入 joinus 导航 nav 底部 footer 注册 register 滚动 scroll 页面主体 main 新闻 news 主导航 mainnav 内容 content 按钮 button 顶导航 topnav 标签页 tab 服务 service 子导航 subnav 版权 copyright 注释 note 菜单 menu 登录 login 提示信息 msg 子菜单 submenu 列表 list 标题 title 子菜单内容 subMenuContent 侧边栏 sidebar 指南 guide 标志 logo 搜索 search 下载 download 广告 banner 图标 icon 状态 status 页面中部 mainbody 表格 table 投票 vote 小技巧 tips 列定义 column_1of3 友情链接 friendlink","categories":[{"name":"web","slug":"web","permalink":"http://flyingmcdonald.github.io/categories/web/"}],"tags":[{"name":"css","slug":"css","permalink":"http://flyingmcdonald.github.io/tags/css/"}]},{"title":"Java数据结构---广度优先搜索遍历","slug":"Java数据结构-广度优先搜索遍历","date":"2019-08-23T15:36:30.000Z","updated":"2019-08-23T16:29:17.186Z","comments":true,"path":"Java数据结构-广度优先搜索遍历/","link":"","permalink":"http://flyingmcdonald.github.io/Java数据结构-广度优先搜索遍历/","excerpt":"介绍 广度优先搜索是一种广泛运用在树或图这类数据结构中，遍历或搜索的算法。 该算法从一个根节点开始，首先访问节点本身。 然后遍历它的相邻节点，其次遍历它的二级邻节点、三级邻节点，以此类推。 当我们在树中进行广度优先搜索时，我们访问的节点的顺序是按照层序遍历顺序的。","text":"介绍 广度优先搜索是一种广泛运用在树或图这类数据结构中，遍历或搜索的算法。 该算法从一个根节点开始，首先访问节点本身。 然后遍历它的相邻节点，其次遍历它的二级邻节点、三级邻节点，以此类推。 当我们在树中进行广度优先搜索时，我们访问的节点的顺序是按照层序遍历顺序的。 通常，我们使用一个叫做队列的数据结构来帮助我们做广度优先搜索。 这是一个广度优先搜索示例 算法 迭代算法 初始化队列只包含一个节点 root 当队列非空的时候： 在输出结果 datas 中插入一个空列表，开始当前层的算法。 计算当前层有多少个元素：等于队列的长度。 将这些元素从队列中弹出，并加入 datas 当前层的空列表中。 将他们的孩子节点作为下一层压入队列中。 123456789101112131415161718192021222324252627282930313233343536 /**迭代算法**/ /** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */ public class Solution &#123; List&lt;List&lt;Integer&gt;&gt; datas = new ArrayList&lt;List&lt;Integer&gt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; if (root == null) &#123; return datas; &#125; queue.offer(root); while (!queue.isEmpty()) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; TreeNode node = queue.poll(); if(node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; list.add(node.val); &#125; datas.add(list); &#125; return datas; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://flyingmcdonald.github.io/categories/数据结构/"}],"tags":[{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/tags/java/"},{"name":"数据结构","slug":"数据结构","permalink":"http://flyingmcdonald.github.io/tags/数据结构/"}]},{"title":"Java数据结构---二叉树","slug":"Java数据结构-二叉树","date":"2019-08-22T16:21:20.000Z","updated":"2019-08-23T15:33:02.163Z","comments":true,"path":"Java数据结构-二叉树/","link":"","permalink":"http://flyingmcdonald.github.io/Java数据结构-二叉树/","excerpt":"介绍 树 是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。 树里的每一个节点有一个根植和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有N 个节点和N-1 条边的一个有向无环图。 二叉树是一种更为典型的树树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。","text":"介绍 树 是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。 树里的每一个节点有一个根植和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有N 个节点和N-1 条边的一个有向无环图。 二叉树是一种更为典型的树树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。 二叉树的遍历 前序遍历遍历顺序：根节点—&gt;左子树—&gt;右子树 中序遍历遍历顺序：左子树—&gt;根节点—&gt;右子树 后序遍历遍历顺序：左子树—&gt;右子树—&gt;根节点 遍历算法 前序遍历 示例： 12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,2,3] 12345678910111213141516171819202122/** 递归算法 **//** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; List&lt;Integer&gt; datas = new ArrayList&lt;Integer&gt;(); public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; while(root != null)&#123; datas.add(root.val); preorderTraversal(root.left); preorderTraversal(root.right); return datas; &#125; return datas; &#125;&#125; 中序遍历 示例： 1234567输入: [1,null,2,3] 1 \\ 2 / 3输出: [1,3,2] 12345678910111213141516171819202122/** 递归算法 **//** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; List&lt;Integer&gt; datas = new ArrayList&lt;Integer&gt;(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; while(root != null)&#123; inorderTraversal(root.left); datas.add(root.val); inorderTraversal(root.right); return datas; &#125; return datas; &#125;&#125; 后序遍历 示例： 1234567输入: [1,null,2,3] 1 \\ 2 / 3输出: [3,2,1] 12345678910111213141516171819202122/** 递归算法 **//** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; List&lt;Integer&gt; datas = new ArrayList&lt;Integer&gt;(); public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; while(root != null)&#123; postorderTraversal(root.left); postorderTraversal(root.right); datas.add(root.val); return datas; &#125; return datas; &#125;&#125; 如果想深入了解树与二叉树，可以阅读这篇博客——Java数据结构和算法（十）——二叉树","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://flyingmcdonald.github.io/categories/数据结构/"}],"tags":[{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/tags/java/"},{"name":"数据结构","slug":"数据结构","permalink":"http://flyingmcdonald.github.io/tags/数据结构/"}]},{"title":"SSM项目踩坑(二)——异步刷新","slug":"SSM项目踩坑-二-——异步请求","date":"2019-08-03T11:51:34.000Z","updated":"2019-08-03T16:24:11.951Z","comments":true,"path":"SSM项目踩坑-二-——异步请求/","link":"","permalink":"http://flyingmcdonald.github.io/SSM项目踩坑-二-——异步请求/","excerpt":"Ajax(Asynchronous Javascript + XML),异步的JavaScript和XML，能在不重新加载整个web页面的前提下刷新数据更改的部分。","text":"Ajax(Asynchronous Javascript + XML),异步的JavaScript和XML，能在不重新加载整个web页面的前提下刷新数据更改的部分。 优点 无刷新更新数据AJAX最大优点就是能在不刷新整个页面的前提下与服务器通信维护数据。这使得Web应用程序更为迅捷地响应用户交互，并避免了在网络上发送那些没有改变的信息，减少用户等待时间，带来非常好的用户体验。 异步与服务器通信AJAX使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。优化了Browser和Server之间的沟通，减少不必要的数据传输、时间及降低网络上数据流量。 前端和后端负载平衡AJAX可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，AJAX的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担，提升站点性能。 基于标准被广泛支持AJAX基于标准化的并被广泛支持的技术，不需要下载浏览器插件或者小程序，但需要客户允许JavaScript在浏览器上执行。随着Ajax的成熟，一些简化Ajax使用方法的程序库也相继问世。同样，也出现了另一种辅助程序设计的技术，为那些不支持JavaScript的用户提供替代功能。 界面与应用分离Ajax使WEB中的界面与应用分离（也可以说是数据与呈现分离），有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。 缺点 AJAX干掉了Back和History功能，即对浏览器机制的破坏在动态更新页面的情况下，用户无法回到前一个页面状态，因为浏览器仅能记忆历史记录中的静态页面。一个被完整读入的页面与一个已经被动态修改过的页面之间的差别非常微妙；用户通常会希望单击后退按钮能够取消他们的前一次操作，但是在Ajax应用程序中，这将无法实现。后退按钮是一个标准的web站点的重要功能，但是它没法和js进行很好的合作。这是Ajax所带来的一个比较严重的问题，因为用户往往是希望能够通过后退来取消前一次操作的。那么对于这个问题有没有办法？答案是肯定的，用过Gmail的知道，Gmail下面采用的Ajax技术解决了这个问题，在Gmail下面是可以后退的，但是，它也并不能改变Ajax的机制，它只是采用的一个比较笨但是有效的办法，即用户单击后退按钮访问历史记录时，通过创建或使用一个隐藏的IFRAME来重现页面上的变更。（例如，当用户在Google Maps中单击后退时，它在一个隐藏的IFRAME中进行搜索，然后将搜索结果反映到Ajax元素上，以便将应用程序状态恢复到当时的状态。）但是，虽然说这个问题是可以解决的，但是它所带来的开发成本是非常高的，并与Ajax框架所要求的快速开发是相背离的。这是Ajax所带来的一个非常严重的问题。一个相关的观点认为，使用动态页面更新使得用户难于将某个特定的状态保存到收藏夹中。该问题的解决方案也已出现，大部分都使用URL片断标识符（通常被称为锚点，即URL中#后面的部分）来保持跟踪，允许用户回到指定的某个应用程序状态。（许多浏览器允许JavaScript动态更新锚点，这使得Ajax应用程序能够在更新显示内容的同时更新锚点。）这些解决方案也同时解决了许多关于不支持后退按钮的争论。 AJAX的安全问题AJAX技术给用户带来很好的用户体验的同时也对IT企业带来了新的安全威胁，Ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。Ajax的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远端服务器上建立新的攻击。还有Ajax也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、SQL注入攻击和基于Credentials的安全漏洞等等。 对搜索引擎支持较弱对搜索引擎的支持比较弱。如果使用不当，AJAX会增大网络数据的流量，从而降低整个系统的性能。 破坏程序的异常处理机制至少从目前看来，像Ajax.dll，Ajaxpro.dll这些Ajax框架是会破坏程序的异常机制的。关于这个问题，曾在开发过程中遇到过，但是查了一下网上几乎没有相关的介绍。后来做了一次试验，分别采用Ajax和传统的form提交的模式来删除一条数据……给我们的调试带来了很大的困难。 违背URL和资源定位的初衷。例如，我给你一个URL地址，如果采用了Ajax技术，也许你在该URL地址下面看到的和我在这个URL地址下看到的内容是不同的。这个和资源定位的初衷是相背离的。 AJAX不能很好支持移动设备。一些手持设备（如手机、PDA等）现在还不能很好的支持Ajax，比如说我们在手机的浏览器上打开采用Ajax技术的网站时，它目前是不支持的。 客户端过肥，太多客户端代码造成开发上的成本。编写复杂、容易出错 ；冗余代码比较多（层层包含js文件是AJAX的通病，再加上以往的很多服务端代码现在放到了客户端）；破坏了Web的原有标准。 jQuery中ajax的使用 在jQuery中ajax被封装成一个$.ajax函数，常用参数如下： 123456789101112131415161718192021222324252627$.ajax(&#123; type : \"GET or POST\", //请求类型 data : &#123; ... //需要提交的数据 &#125;, url : \" \" //数据提交的路径 beforeSend : function()&#123; ... //数据提交前所做的事情，一般用于数据的校验 return true; &#125;, success : function(result)&#123; //请求成功后的回调函数 if(result.success)&#123; //判断数据返回是否成功，result是后台返回的一个对象 ... &#125;else&#123; ... &#125; &#125;, error : function()&#123; //请求失败后的回调函数 ... &#125;&#125;); 实例——实现登录功能 js代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function dologin() &#123; /** 获取表单元素 floginacct——登录帐号 fusername——密码 ftype——用户类型 **/ var floginacct = $(\"#floginacct\"); var fuserpswd = $(\"#fuserpswd\"); var ftype = $(\"#ftype\"); $.ajax(&#123; type : \"POST\", data : &#123; //以json格式获取对应值 \"loginacct\" : floginacct.val(), \"userpswd\" : fuserpswd.val(), \"type\" : ftype.val() &#125;, url : \"$&#123;APP_PATH&#125;/doLogin.do\", //数据提交路径 beforeSend : function() &#123; //一般做表单校验 loadingIndex = layer.msg(\"处理中...\", &#123;icon:16&#125;); //弹层组件，类似于alert(\"...\") //对于表单而言不能用null进行判断，如果文本框什么都没有输入，获取的值是空串\"\" //$.trim(String) 去掉字符串前后两端的空格 if ($.trim(floginacct.val()) == \"\") &#123; layer.msg(\"用户帐户不能为空，请重新输入！\", &#123;time:2000, icon:5, shift:6&#125;, function() &#123; floginacct.val(\"\"); floginacct.focus(); &#125;); return false; &#125; if ($.trim(fuserpswd.val()) == \"\") &#123; layer.msg(\"用户密码不能为空，请重新输入！\", &#123;time:2000, icon:5, shift:6&#125;, function() &#123; floginacct.val(\"\"); floginacct.focus(); &#125;); return false; &#125; return true; &#125;, success : function(result) &#123; //&#123;\"success\":false,\"message\":\"登录失败！\"&#125; 或 &#123;\"success\":true&#125; layer.close(loadingIndex); if (result.success) &#123; window.location.href=\"$&#123;APP_PATH &#125;/main.htm\"; //数据请求成功并无异常 &#125;else &#123; //数据请求成功但抛异常 layer.msg(result.message, &#123;time:2000, icon:5, shift:6&#125; ); &#125; &#125;, error : function() &#123; //请求失败 layer.msg(\"登录失败！\", &#123;time:2000, icon:5, shift:6&#125;); &#125; &#125;); Controller层代码： 12345678910111213141516171819202122232425262728 //异步请求：处理请求后页面进行局部刷新，所以不会闪烁 //@ResponseBody 结合Jackson组件，将返回结果转换为字符串，将JSON串以流的形式返回给客户端. @ResponseBody @RequestMapping(\"/doLogin\") public Object doLogin( String loginacct, String userpswd, String type, HttpSession session) &#123; //AjaxResult是一个工具类，用于方便返回信息 AjaxResult result = new AjaxResult(); try &#123; Map&lt;String,Object&gt; paramMap = new HashMap&lt;String,Object&gt;(); paramMap.put(\"loginacct\", loginacct); paramMap.put(\"userpswd\", MD5Util.digest(userpswd)); paramMap.put(\"type\", type); User user = userService.login(paramMap); session.setAttribute(Const.LOGIN_USER, user); result.setSuccess(true); // &#123;\"success\":true&#125; &#125; catch (Exception e) &#123; result.setMessage(\"登录失败！\"); e.printStackTrace(); result.setSuccess(false); // &#123;\"success\":false,\"message\":\"登录失败！\"&#125; &#125; return result ;&#125; AjaxResult类： 12345678910111213141516171819202122public class AjaxResult &#123; private boolean success; private String message; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public boolean getSuccess() &#123; return success; &#125; public void setSuccess(boolean success) &#123; this.success = success; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/tags/java/"},{"name":"ssm","slug":"ssm","permalink":"http://flyingmcdonald.github.io/tags/ssm/"},{"name":"ajax","slug":"ajax","permalink":"http://flyingmcdonald.github.io/tags/ajax/"}]},{"title":"JVM加载类规则——双亲委派机制","slug":"JVM加载类规则——双亲委派机制","date":"2019-07-26T09:22:54.000Z","updated":"2019-07-26T10:05:01.115Z","comments":true,"path":"JVM加载类规则——双亲委派机制/","link":"","permalink":"http://flyingmcdonald.github.io/JVM加载类规则——双亲委派机制/","excerpt":"在JVM中，加载类，需要遵守双亲委派机制…","text":"在JVM中，加载类，需要遵守双亲委派机制… 双亲委派机制 在加载类时，应用类加载器首先执行加载，但不是立即加载，而是委派给父类加载器——扩展类加载器进行加载。 而扩展类加载器也不是立即加载，而是继续委派给父类加载器——启动类加载器进行加载。 如果启动类加载器能够加载，则直接加载使用；如果不能加载，则抛异常； 这时，扩展类加载器继续加载，如果能够加载，则直接加载使用；如果不能加载，则抛异常； 这时，应用类加载器继续加载，如果能够加载，则直接加载使用；如果不能加载，则抛异常；最终显示找不到类异常（ClassNotFoundException）。 加载器位置 启动类加载器：$JRE_HOME/classes目录（classes需手动创建） 扩展类加载器：$JRE_HOME/lib/classes目录（classes需手动创建） 应用类加载器：可存放到任意目录下 图解","categories":[{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://flyingmcdonald.github.io/tags/jvm/"}]},{"title":"静态包含,动态包含与注释","slug":"静态包含-动态包含与注释","date":"2019-07-26T08:21:45.000Z","updated":"2019-07-26T08:57:41.107Z","comments":true,"path":"静态包含-动态包含与注释/","link":"","permalink":"http://flyingmcdonald.github.io/静态包含-动态包含与注释/","excerpt":"在jsp页面中，静态包含与动态包含的区别以及HEML注释与JSP注释的区别","text":"在jsp页面中，静态包含与动态包含的区别以及HEML注释与JSP注释的区别 静态包含—&lt;%@ include page=”” %&gt; 静态包含：将所包含的页面内容加入页面一起编译，被包含的文件不会单独生成字节码文件。 动态包含—&lt;jsp:include page=”” /&gt; 动态包含：被包含的内容也会独立生成字节码文件。 注释 HTML注释：&lt;!-- --&gt;注释的内容参与编译，会生成到源码中。所以不能用html注释EL表达式和JSPL标签库。 JSP注释：&lt;%-- --%&gt;注释的内容不参与编译，不会生成到源码中。","categories":[{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/tags/java/"},{"name":"jsp","slug":"jsp","permalink":"http://flyingmcdonald.github.io/tags/jsp/"}]},{"title":"我惊了！原来部署项目的上下文路径可以这么短","slug":"我惊了！原来部署项目的上下文路径可以这么短","date":"2019-07-21T09:00:21.000Z","updated":"2019-07-21T11:44:32.243Z","comments":true,"path":"我惊了！原来部署项目的上下文路径可以这么短/","link":"","permalink":"http://flyingmcdonald.github.io/我惊了！原来部署项目的上下文路径可以这么短/","excerpt":"在开发javaweb项目时用http://localhost:端口号/项目名称/index.jsp这样巨长无比的上下文路径觉得不顺眼？配置一下，你就能用http://localhost愉快的测试代码啦 :)","text":"在开发javaweb项目时用http://localhost:端口号/项目名称/index.jsp这样巨长无比的上下文路径觉得不顺眼？配置一下，你就能用http://localhost愉快的测试代码啦 :) 环境 Eclipse 原理 Tomcat服务器在部署项目时将项目默认放在webapp目录下，而要省略上下文路径需要项目指定放在webapp/ROOT目录内. 一、从项目Properties面板中改路径 进行配置前需要先清理Tomcat服务器缓存，具体请Google一下 选中你的项目，右键打开properties 在搜索框搜索Web Project Settings 将Context root的内容改为”/“ OK！ 二、从配置文件中改路径 选中你的项目 点击右边的V形图标 点击Filters 取消选中.* resource，保存退出 展开你的项目，你能看见多了一个.settings文件夹，到里面找到org.eclipse.wst.common.component文件 找到org.eclipse.wst.common.component最底部的属性并做下面修改 1&lt;property name=\"context-root\" value=\"/\"/&gt; OK！","categories":[{"name":"其它","slug":"其它","permalink":"http://flyingmcdonald.github.io/categories/其它/"}],"tags":[{"name":"其它","slug":"其它","permalink":"http://flyingmcdonald.github.io/tags/其它/"}]},{"title":"SSM项目踩坑系列(一)","slug":"SSM项目踩坑系列-一","date":"2019-07-19T15:20:37.000Z","updated":"2019-07-21T11:57:45.180Z","comments":true,"path":"SSM项目踩坑系列-一/","link":"","permalink":"http://flyingmcdonald.github.io/SSM项目踩坑系列-一/","excerpt":"在经过一段时间对i3wm的折腾，我终于放弃了…于是从今天开始正式踏上ssm框架学习(踩坑)之路。:)","text":"在经过一段时间对i3wm的折腾，我终于放弃了…于是从今天开始正式踏上ssm框架学习(踩坑)之路。:) 环境 Tomcat 9 Maven 3.6.0 Eclipse 4.11.0 问题一 在开启Tomcat服务器遇到 class path resource [xxx/xxx] cannot be opened because it does not exist 怎么办？ 解决方法 此类问题一般都是由于目标文件位置与Spring的.xml配置文件内关于目标文件的ClassPath 不同所导致，所以解决此类问题只需要将ClassPath与目标文件路径一致即可。 例子 我遇到的情况是class path resource [config/jdbc.properties] cannot be opened because it does not exist，当时我查看Spring-context.xml时看到的是这个: 123&lt;bean id=\"propertyPlaceholderConfigurer\" class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"locations\" value=\"classpath:config/jdbc.properties\" /&gt;&lt;/bean&gt; 里面的内容需要我将jdbc.properties放入config文件夹中，可是我没有config文件夹呀，所以才会出现上述的异常。这里我新建一个config文件夹再将jdbc.properties移到里面，至此大功告成。 问题二 创建的maven项目如何部署到Tomcat服务器？ 解决方法 选中maven项目并按Alt+Enter打开properties先取消选中Dynamic Web Moudle点击Apply，然后再次选中Dynamic Web Moudle 注意Dynamic Web Moudle版本需保持一致 此时会出现这个:点它又会出现这个:然后将WebContent改为/src/main/webapp，记得要勾选下面的Generate web.xml deployment descriptor.至此大功告成.","categories":[{"name":"-java开发","slug":"java开发","permalink":"http://flyingmcdonald.github.io/categories/java开发/"}],"tags":[{"name":"java","slug":"java","permalink":"http://flyingmcdonald.github.io/tags/java/"},{"name":"ssm框架","slug":"ssm框架","permalink":"http://flyingmcdonald.github.io/tags/ssm框架/"},{"name":"踩坑系列","slug":"踩坑系列","permalink":"http://flyingmcdonald.github.io/tags/踩坑系列/"}]},{"title":"Hexo博客的搭建以及Next主题的优化","slug":"Hexo博客的搭建以及Next主题的优化","date":"2019-07-07T07:21:11.000Z","updated":"2019-12-13T06:49:38.929Z","comments":true,"path":"Hexo博客的搭建以及Next主题的优化/","link":"","permalink":"http://flyingmcdonald.github.io/Hexo博客的搭建以及Next主题的优化/","excerpt":"从博客搭建到选择主题以及优化主题已经过了一段时间了，在此用这篇文章来记录这段时间的学习(摸鱼)…","text":"从博客搭建到选择主题以及优化主题已经过了一段时间了，在此用这篇文章来记录这段时间的学习(摸鱼)… Hexo搭建安装Node.js 首先需要安装 Node.js : 将下载下来的压缩包进行解压: 1tar -xvf node-v12.6.0-linux-x64.tar.xz 确认一下nodejs下bin目录是否有node 和npm文件，如果有执行软连接，如果没有重新下载执行上边步骤… 建立软连接： 123sudo ln -s nodejs/bin/npm-cli.js /usr/local/bin/npmsudo ln -s nodejs/bin/npx-cli.js /usr/local/bin/npx 检验npm是否为全局变量，在终端中输入 npm –version 若出现版本号，则大功告成： 12npm --version6.9.0 由于Node的默认镜像源在国外，国内使用的话速度堪忧，所以换成淘宝源，之后我们就可以用cnpm代替npm了： 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装Hexo 确定Node.js安装无误后，接下来就可以安装Hexo了… 创建一个Blog目录，这个目录将是博客的根目录： 1mkdir Blog 进入Blog目录里运行以下命令： 1cnpm install -g hexo-cli //安装Hexo 初始化Hexo 12hexo initcnpm install 当Hexo初始化之后，Blog目录下会出现以下几个文件/目录： 123456Blog├── _config.yml //站点配置文件├── package.json //应用数据文件├── scaffolds //用于放置创建新博文时所需的模板├── source //站点源文件夹└── themes //主题文件夹 初始化之后就可以运行 hexo s 来在本地预览你的博客了 将Hexo部署到Github上 拥有一个github帐号并且创建一个名为username.github.io的仓库(username为你的github用户名且最好为小写)。 进入博客的根目录运行命令： 1cnpm install hexo-deployer-git --save //部署到github时用的插件 打开站点配置文件，找到下面代码并按下面的格式填入相关信息： 1234deploy: type: git repo: https://username:password@github.com/username/username.github.io branch: master 用以下命令将博客部署到github上： 123hexo clean //清空hexo数据hexo g //生成文件hexo d //部署到github 打开github.io仓库，如果看见hexo文件则一切OK 更换主题 虽然Hexo在初始化是会下载一个默认的主题，但由于这个主题并不美观，因此更换主题就是义不容辞的事情啦，所以下面会以更换nexT主题为例子来讲解如何更换主题。 下载nexT 12cd Bloggit clone https://github.com/theme-next/hexo-theme-next/ themes/next 更换nexT 打开站点配置文件，找到 theme 将内容改成： 1theme: next 在根目录运行： 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d nexT主题的优化 在更换主题后当然要根据自己的爱好进行一番折腾，这里提供了一些主题的优化配置。因为在next的配置文件名也是_config.yml，所以下面统一称next的配置文件为主题配置文件。设置语言 打开站点配置文件，找到 language 属性将其设为 zh-CN 设置头像 打开主题配置文件，找到avatar属性： 12345avatar: url: PATH //例：/Blog/source/blogImg/blog.png，PATH为:/blogImg/blog.png rounded: true or false //将头像显示为圆形 opacity: 0~1 //头像透明度 rotated: true or false //光标放在头像上时头像旋转 字数统计和阅读时间 进入博客根目录，运行命令： 1cnpm install hexo-symbols-count-time --save 打开主题配置文件，找到symbols_count_time属性： 1234567symbols_count_time: separated_meta: true or false //分割符号 item_text_post: true or false //文章字数 item_text_total: true or false //所有文章的总字数 awl: 2 //平均字符长度，en=4、cn=2 wpm: 275 //阅读速度 suffix: mins. //时间计量单位 详情描述 配置完后复制一份到站点配置文件 侧边栏显示阅读进度 打开主题配置文件，找到toc属性并如下配置： 123456toc: enable: true number: true wrap: true expand_all: true max_depth: 6 找到back2top属性并如下配置： 1234back2top: enable: true sidebar: true //返回侧边栏顶端 scrollpercent: true //阅读进度显示 评论功能——gitalk 进入Github主页，依次点击 头像-&gt;settings-&gt;Developer settings-&gt;OAuth Apps-&gt;New OAuth Apps 按照下图填入信息： 注册成功后将会获得一个 client_id 和 client_secret 因为nexT集成了gitalk，所以只需进入主题配置文件找到Gitalk属性填入相应配置即可： 12345678gitalk: enable: true or false github_id: //github用户名 repo: //储存评论用的仓库 client_id: //第三步的client_id client_secret: //第三步的client_secret admin_user: //管理员用户 language: //显示的语言，可用的值：en, es-ES, fr, ru, zh-CN, zh-TW 站点统计——不蒜子 nexT主题也集成了此功能，所以只需进入主题配置文件找到busuanzi属性填入相应配置即可： 12345678busuanzi_count: enable: true or false total_visitors: true or false //站点总的浏览人数 total_visitors_icon: //图标 默认为：user total_views: true or false //站点总的浏览量 total_views_icon: //图标，默认为：eye post_views: //单篇文章的浏览量 post_views_icon: //图标，默认为：eye 背景动画效果——canvas-nest 在nexT目录下运行命令： 1git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest 打开主题配置文件，找到canvas_nest属性并进行配置： 1234567canvas_nest: enable: true or false onmoblie: true or false //在移动端显示 color: \"122,122,122\" //颜色 opacity: 0~1 //透明度 zIndex: -1 //背景层数最好为-1 count: 150 //每行显示的数量 nexT主题内置了多个背景动画效果，但只能启用一个，无法多个并用 博文面板、侧边栏面板的透明度 若想要修改主题的样式，可以在 /next/source/css/_custom/custom.styl 文件里面写入你所需要改变的样式，此文件内的样式会自动覆盖默认样式。例如需要改变博文面板和侧边栏的透明度并添加阴影效果的代码如下： 123456789101112131415161718192021222324252627282930313233343536.content-wrap &#123; background: rgba(255, 255, 255, 0.2); &#125;.header-inner &#123; background: rgba(227, 230, 231, 0.5); border: 1px solid #E3E6E7; border-top: 0px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125;.sidebar-inner &#123; background: rgba(235, 235, 235, 0.5); border: 1px solid #EBEBEB; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125;.sidebar &#123; background: rgba(255, 255, 255, 0.0); &#125;.menu .menu-item a:hover, .menu-item-active a &#123; background: rgba(250, 250, 250, 0.6); border-bottom-color: rgba(250, 250, 250, 0.6); &#125;.post &#123; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 将文章末尾标签前面的’#’改成图标 打开主题配置文件，找到 tag_icon 属性将其改为 true 高级看板娘(说话,变装一应俱全) 在nexT目录下运行命令： 1git clone https://github.com/stevenjoezhang/live2d-widget.git source/live2d-widget 在 layout/_layout.swig 文件的 ** 标签里添加下面三行代码： 12345&lt;script src=\"https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js\"&gt;&lt;/script&gt;&lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css\"/&gt;&lt;script src=\"/live2d-widget/autoload.js\"&gt;&lt;/script&gt; 在主题配置目录里添加配置： 12live2d: enable: true live2d具体配置文件为 source/live2d-widget/ 里的 waifu.css、waifu-tip.css、waifu-tip.json文件。详情请参考live2d-widget :) Note提示块的使用 菜鸡感受…… 其实在一开始我是不知道还有Note提示块这种东西的，直到我看了xiaoding的某一篇博客…然后菜鸡的我花了一大段时间，通过百度、Google搜索各种蒙(菜的人连应该搜哪个关键字都不知道23333)终于让我蒙对了关键字，对！没有搜不到的结果，只有蒙不对的关键字 ：）后来的剧情就顺畅了许多，废话少说，上代码。 这是代码… 1234567891011121314151617181920212223&#123;% note default %&#125;default 提示块标签&#123;% endnote %&#125;&#123;% note primary %&#125;primary 提示块标签&#123;% endnote %&#125;&#123;% note success %&#125;success 提示块标签&#123;% endnote %&#125;&#123;% note info %&#125;info 提示块标签&#123;% endnote %&#125;&#123;% note warning %&#125;warning 提示块标签&#123;% endnote %&#125;&#123;% note danger %&#125;danger 提示块标签&#123;% endnote %&#125; 这是效果… default 提示块标签 primary 提示块标签 success 提示块标签 info 提示块标签 warning 提示块标签 danger 提示块标签 在主题配置文件中可以修改风格 12345678910111213# Note tag (bs-callout). note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: modern icons: true border_radius: 0 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0 参考文章：在hexo-NexT中插入note提示块next主题官方最全文档","categories":[{"name":"博客","slug":"博客","permalink":"http://flyingmcdonald.github.io/categories/博客/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://flyingmcdonald.github.io/tags/Linux/"},{"name":"博客","slug":"博客","permalink":"http://flyingmcdonald.github.io/tags/博客/"}]},{"title":"Linux下误将文件覆盖后的解决方法","slug":"Linux下误将文件覆盖后的解决方法","date":"2019-07-04T08:09:17.000Z","updated":"2019-07-06T12:55:19.714Z","comments":true,"path":"Linux下误将文件覆盖后的解决方法/","link":"","permalink":"http://flyingmcdonald.github.io/Linux下误将文件覆盖后的解决方法/","excerpt":"事件起因对重定向输出符号 &gt;(覆盖) 和 &gt;&gt;(从最后一行开始追加内容) 错误使用导致文件内容被覆盖(使用 mv 命令覆盖也适用)","text":"事件起因对重定向输出符号 &gt;(覆盖) 和 &gt;&gt;(从最后一行开始追加内容) 错误使用导致文件内容被覆盖(使用 mv 命令覆盖也适用) 解决方法经过查找资料后发现被覆盖的文件内容能够通过 grep 与 dd 这两个命令来找到 开始查找首先用 pwd 命令确认文件所在的目录(我的是在/home目录)， 用 fdisk -h 确认文件所在目录挂在哪个磁盘 123456789Filesystem Size Used Avail Use% Mounted onudev 3.9G 0 3.9G 0% /devtmpfs 787M 18M 770M 3% /run/dev/sda4 108G 50G 53G 49% /tmpfs 3.9G 63M 3.8G 2% /dev/shmtmpfs 5.0M 4.0K 5.0M 1% /run/locktmpfs 3.9G 0 3.9G 0% /sys/fs/cgroup/dev/sda3 512M 5.3M 507M 2% /boot/efitmpfs 787M 28K 787M 1% /run/user/1000 因为我用的是整个磁盘做的/目录(图方便)，所以可以看到我的/目录挂在 /dev/sda4 上。然后用使用 grep -a -b 命令在磁盘上通过文件内容中比较有代表性的字符串(字符串越长搜索结果越准确)来查找文件所在偏移的位置，并返回部分内容。比如： 1sudo grep -a -b 'echo \"YYFNB\"' /dev/sda4 grep中几个参数的解释-a用来把二进制文件当文本文件处理-b用来保证显示查找出的结果的偏移位置 其中 echo “YYFNB” 是我文件中比较有代表性的字符串，而 /dev/sda4 是我文件所在的磁盘位置。执行命令后过一会会出现搜索结果(一般查找的文件都会在前几个结果里)： 115938740228 : echo \"YYFNB\" 然后记住搜索结果中前面的偏移信息 15938740228 ，接着使用 dd 命令利用偏移信息直接从磁盘读取文件内容： 1dd if=/dev/sda4 count=1 skip=$(expr 15938740228 / 512) dd中使用的几个参数的解释count指明读取多少个数据块if指定读取源skip指定跳过多少个块（后面除以512是因为，skip是跳过ibs-sized blocks，而ibs默认大小为512） 注意事项：字符串一定要足够长以及有一定的单一性不然可能有多个搜索结果 参考文章https://my.oschina.net/u/573025/blog/378629","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://flyingmcdonald.github.io/tags/Linux/"},{"name":"文件管理","slug":"文件管理","permalink":"http://flyingmcdonald.github.io/tags/文件管理/"}]},{"title":"Markdown的基本使用方法","slug":"Markdown的基本使用方法","date":"2019-07-03T06:36:27.000Z","updated":"2019-07-13T08:59:14.194Z","comments":true,"path":"Markdown的基本使用方法/","link":"","permalink":"http://flyingmcdonald.github.io/Markdown的基本使用方法/","excerpt":"标题markdown的标题用#来表示,#的个数表示标题的级数:eg: 123456# 这是一个一级标题## 这是一个二级标题### 这是一个三级标题#### 这是一个四级标题##### 这是一个五级标题###### 这是一个六级标题","text":"标题markdown的标题用#来表示,#的个数表示标题的级数:eg: 123456# 这是一个一级标题## 这是一个二级标题### 这是一个三级标题#### 这是一个四级标题##### 这是一个五级标题###### 这是一个六级标题 字体 加粗 将要加粗的文字用两个**包起来 eg： 这是粗体 斜体 将要倾斜的文字用一个*包起来 eg: 这是斜体 加粗斜体 将要加粗倾斜的文字用三个***包起来 eg： 这是加粗斜体 删除线 将要加删除线的文字用两个~~包起来 eg：这是将要删除的文字 引用在引用的文字前面加上&gt;即可 eg： 这是引用的内容 这也是引用的内容 引中引 分割线用三个及其以上的-或*表示 图片语法： 12345![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title就是图片的标题，当鼠标移动到图片上时显示的内容。title可加可不加 eg： 超链接语法： 12345[超链接名](超链接地址 &quot;超链接title&quot;)超链接地址要加http://或https://title可加可不加 eg：baidu 列表1. 无序列表语法：无序列表用- + *任何一种都可以 12345- 列表内容+ 列表内容* 列表内容注：要加空格 2. 有序列表语法： 有序列表只需在文字前面加上1. 123456eg： 1. 列表内容 2. 列表内容 3. 列表内容注：序号和文字之间要加空格 表格1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 eg： 姓名 技能 表头 刘 关 张 代码语法：单行代码用一个反引号包起来多行代码用三个反引号包起来 流程图1234567st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op default 提示块标签 Text","categories":[],"tags":[{"name":"技术学习","slug":"技术学习","permalink":"http://flyingmcdonald.github.io/tags/技术学习/"}]}]}